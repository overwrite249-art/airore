<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Air Ore - Mining Air Since 2026</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-tertiary: #1a1a25;
            --neon-blue: #00f5ff;
            --neon-pink: #ff00ff;
            --neon-green: #00ff88;
            --neon-yellow: #ffff00;
            --neon-orange: #ff8800;
            --text-primary: #ffffff;
            --text-secondary: #888899;
            --diamond: #b9f2ff;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Animations */
        @keyframes glow {
            0%, 100% { filter: drop-shadow(0 0 5px var(--neon-blue)) drop-shadow(0 0 10px var(--neon-blue)); }
            50% { filter: drop-shadow(0 0 20px var(--neon-blue)) drop-shadow(0 0 40px var(--neon-blue)); }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px) rotate(-1deg); }
            75% { transform: translateX(5px) rotate(1deg); }
        }

        @keyframes rainbow {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }

        @keyframes slideIn {
            from { transform: translateY(100px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        @keyframes spinBounce {
            0% { transform: rotate(0deg) translateY(0); }
            25% { transform: rotate(180deg) translateY(-100px); }
            50% { transform: rotate(360deg) translateY(0); }
            75% { transform: rotate(540deg) translateY(-50px); }
            100% { transform: rotate(720deg) translateY(0); }
        }

        @keyframes fall {
            to { transform: translateY(200vh) rotate(1440deg); opacity: 0; }
        }

        @keyframes particleFloat {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-100px) scale(0); opacity: 0; }
        }

        .shake {
            animation: shake 0.1s ease-in-out;
        }

        /* Initial Mining Screen */
        #initial-mining {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, #0f0f1a 0%, #000005 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        #initial-mining.hidden {
            display: none;
        }

        .mining-title {
            font-size: 3rem;
            background: linear-gradient(90deg, var(--neon-blue), var(--neon-pink), var(--neon-blue));
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: rainbow 3s linear infinite;
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(0, 245, 255, 0.5);
        }

        .mining-subtitle {
            color: var(--text-secondary);
            font-size: 1.2rem;
            margin-bottom: 40px;
        }

        .ore-rock {
            width: 200px;
            height: 200px;
            background: linear-gradient(135deg, #2a2a3a, #1a1a2a, #3a3a4a);
            border-radius: 30% 70% 70% 30% / 30% 30% 70% 70%;
            cursor: pointer;
            position: relative;
            transition: all 0.1s ease;
            box-shadow: 0 0 30px rgba(0, 245, 255, 0.3), inset 0 0 30px rgba(0, 0, 0, 0.5);
        }

        .ore-rock:hover {
            transform: scale(1.05);
            box-shadow: 0 0 50px rgba(0, 245, 255, 0.5), inset 0 0 30px rgba(0, 0, 0, 0.5);
        }

        .ore-rock:active {
            transform: scale(0.95);
        }

        .ore-rock::before {
            content: '‚õèÔ∏è';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4rem;
            animation: float 2s ease-in-out infinite;
        }

        .ore-veins {
            position: absolute;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                45deg,
                transparent,
                transparent 10px,
                rgba(0, 245, 255, 0.1) 10px,
                rgba(0, 245, 255, 0.1) 20px
            );
            border-radius: inherit;
            animation: glow 2s ease-in-out infinite;
        }

        .mining-progress {
            margin-top: 40px;
            text-align: center;
        }

        .progress-bar {
            width: 300px;
            height: 20px;
            background: var(--bg-tertiary);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid var(--neon-blue);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--neon-blue), var(--neon-pink));
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 20px var(--neon-blue);
        }

        .progress-text {
            margin-top: 10px;
            font-size: 1.5rem;
            color: var(--neon-blue);
        }

        /* Particle System */
        .particle {
            position: fixed;
            pointer-events: none;
            font-size: 1.5rem;
            animation: particleFloat 1s ease-out forwards;
            z-index: 9999;
        }

        /* Bouncing Popup */
        .bouncing-popup {
            position: fixed;
            padding: 30px 50px;
            background: linear-gradient(135deg, var(--bg-secondary), var(--bg-tertiary));
            border: 3px solid var(--neon-green);
            border-radius: 20px;
            font-size: 1.5rem;
            text-align: center;
            z-index: 2000;
            box-shadow: 0 0 50px var(--neon-green);
        }

        .bouncing-popup h2 {
            color: var(--neon-green);
            margin-bottom: 10px;
        }

        /* Main App */
        #main-app {
            display: none;
            min-height: 100vh;
            padding-bottom: 60px;
        }

        #main-app.visible {
            display: block;
            animation: slideIn 1s ease-out;
        }

        /* Top Bar */
        .top-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 70px;
            background: linear-gradient(180deg, var(--bg-secondary), transparent);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 30px;
            z-index: 100;
            border-bottom: 1px solid rgba(0, 245, 255, 0.2);
        }

        .logo {
            font-size: 1.8rem;
            font-weight: bold;
            background: linear-gradient(90deg, var(--neon-blue), var(--neon-pink));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .logo:hover {
            transform: scale(1.1);
        }

        .ore-display {
            display: flex;
            gap: 30px;
        }

        .ore-counter {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            background: var(--bg-tertiary);
            border-radius: 50px;
            border: 2px solid var(--neon-blue);
            transition: all 0.3s ease;
        }

        .ore-counter:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.3);
        }

        .ore-counter.diamond {
            border-color: var(--diamond);
        }

        .ore-counter.diamond:hover {
            box-shadow: 0 0 20px rgba(185, 242, 255, 0.5);
        }

        .ore-counter.gems {
            border-color: var(--neon-pink);
        }

        .ore-counter.gems:hover {
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
        }

        .ore-icon {
            font-size: 1.5rem;
        }

        .ore-amount {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--neon-blue);
        }

        .ore-counter.diamond .ore-amount {
            color: var(--diamond);
        }

        .ore-counter.gems .ore-amount {
            color: var(--neon-pink);
        }

        /* Navigation */
        .nav-tabs {
            display: flex;
            justify-content: center;
            gap: 10px;
            padding: 90px 20px 20px;
            flex-wrap: wrap;
        }

        .nav-tab {
            padding: 15px 30px;
            background: var(--bg-tertiary);
            border: 2px solid transparent;
            border-radius: 15px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
            font-weight: bold;
            position: relative;
            overflow: hidden;
        }

        .nav-tab::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s ease;
        }

        .nav-tab:hover::before {
            left: 100%;
        }

        .nav-tab:hover {
            border-color: var(--neon-blue);
            color: var(--text-primary);
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(0, 245, 255, 0.2);
        }

        .nav-tab.active {
            border-color: var(--neon-pink);
            color: var(--text-primary);
            background: linear-gradient(135deg, var(--bg-tertiary), rgba(255, 0, 255, 0.1));
        }

        /* Content Sections */
        .content-section {
            display: none;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
            animation: slideIn 0.5s ease-out;
        }

        .content-section.active {
            display: block;
        }

        .section-title {
            font-size: 2.5rem;
            text-align: center;
            margin-bottom: 30px;
            background: linear-gradient(90deg, var(--neon-blue), var(--neon-pink));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* Mine Section */
        .mine-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
        }

        .big-ore {
            width: 300px;
            height: 300px;
            background: radial-gradient(ellipse at 30% 30%, #4a4a5a, #2a2a3a, #1a1a2a);
            border-radius: 40% 60% 60% 40% / 40% 40% 60% 60%;
            cursor: pointer;
            position: relative;
            transition: all 0.1s ease;
            box-shadow: 0 0 50px rgba(0, 245, 255, 0.3), inset -20px -20px 60px rgba(0, 0, 0, 0.5);
        }

        .big-ore:hover {
            box-shadow: 0 0 80px rgba(0, 245, 255, 0.5), inset -20px -20px 60px rgba(0, 0, 0, 0.5);
        }

        .big-ore:active {
            transform: scale(0.95);
        }

        .big-ore::before {
            content: 'üíé';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 5rem;
            animation: float 2s ease-in-out infinite;
        }

        .ore-sparkles {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: inherit;
            overflow: hidden;
        }

        .sparkle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: var(--neon-blue);
            border-radius: 50%;
            animation: glow 1s ease-in-out infinite;
        }

        .mine-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            width: 100%;
            max-width: 800px;
        }

        .stat-card {
            background: var(--bg-tertiary);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            border-color: var(--neon-blue);
            transform: translateY(-5px);
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: var(--neon-blue);
        }

        .stat-label {
            color: var(--text-secondary);
            margin-top: 5px;
        }

        /* Upgrades */
        .upgrades-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }

        .upgrade-card {
            background: var(--bg-tertiary);
            padding: 25px;
            border-radius: 20px;
            border: 2px solid var(--bg-tertiary);
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .upgrade-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(0, 245, 255, 0.1) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .upgrade-card:hover::before {
            opacity: 1;
        }

        .upgrade-card:hover {
            border-color: var(--neon-blue);
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }

        .upgrade-card.owned {
            border-color: var(--neon-green);
            opacity: 0.7;
        }

        .upgrade-card.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .upgrade-icon {
            font-size: 3rem;
            margin-bottom: 15px;
        }

        .upgrade-name {
            font-size: 1.3rem;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .upgrade-desc {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-bottom: 15px;
        }

        .upgrade-cost {
            display: inline-block;
            padding: 8px 20px;
            background: linear-gradient(90deg, var(--neon-blue), var(--neon-pink));
            border-radius: 20px;
            font-weight: bold;
        }

        .upgrade-card.owned .upgrade-cost {
            background: var(--neon-green);
        }

        /* Minigames Grid */
        .minigames-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .minigame-card {
            background: linear-gradient(135deg, var(--bg-tertiary), var(--bg-secondary));
            padding: 25px;
            border-radius: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            position: relative;
            overflow: hidden;
        }

        .minigame-card::after {
            content: 'PLAY';
            position: absolute;
            bottom: -50px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 30px;
            background: var(--neon-green);
            border-radius: 20px;
            font-weight: bold;
            color: black;
            transition: bottom 0.3s ease;
        }

        .minigame-card:hover::after {
            bottom: 20px;
        }

        .minigame-card:hover {
            border-color: var(--neon-pink);
            transform: translateY(-10px);
            box-shadow: 0 20px 50px rgba(255, 0, 255, 0.2);
        }

        .minigame-card.featured {
            border-color: var(--neon-orange);
            background: linear-gradient(135deg, rgba(255, 136, 0, 0.2), var(--bg-secondary));
        }

        .minigame-icon {
            font-size: 4rem;
            margin-bottom: 15px;
        }

        .minigame-name {
            font-size: 1.3rem;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .minigame-reward {
            color: var(--neon-green);
            font-size: 0.9rem;
        }

        .minigame-diamond {
            color: var(--diamond);
        }

        .featured-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--neon-orange);
            color: black;
            padding: 5px 10px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: bold;
        }

        /* Minigame Modal */
        .game-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 500;
        }

        .game-modal.active {
            display: flex;
        }

        .game-container {
            background: var(--bg-secondary);
            padding: 40px;
            border-radius: 30px;
            border: 3px solid var(--neon-blue);
            max-width: 800px;
            width: 95%;
            max-height: 90vh;
            overflow-y: auto;
            text-align: center;
            position: relative;
            box-shadow: 0 0 100px rgba(0, 245, 255, 0.3);
        }

        .game-container.fullscreen {
            max-width: 100%;
            width: 100%;
            height: 100%;
            max-height: 100%;
            border-radius: 0;
        }

        .game-close {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 2rem;
            cursor: pointer;
            color: var(--text-secondary);
            transition: all 0.3s ease;
            z-index: 10;
        }

        .game-close:hover {
            color: var(--neon-pink);
            transform: rotate(90deg);
        }

        .game-title {
            font-size: 2rem;
            margin-bottom: 20px;
            color: var(--neon-blue);
        }

        .game-area {
            min-height: 300px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
        }

        .game-btn {
            padding: 20px 60px;
            font-size: 1.5rem;
            background: linear-gradient(135deg, var(--neon-blue), var(--neon-pink));
            border: none;
            border-radius: 15px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .game-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px var(--neon-blue);
        }

        .game-btn:active {
            transform: scale(0.95);
        }

        .game-score {
            font-size: 3rem;
            font-weight: bold;
            color: var(--neon-green);
        }

        .game-timer {
            font-size: 2rem;
            color: var(--neon-orange);
        }

        /* AI Chat */
        .chat-container {
            max-width: 900px;
            margin: 0 auto;
            background: var(--bg-tertiary);
            border-radius: 20px;
            overflow: hidden;
            border: 2px solid var(--neon-pink);
        }

        .chat-header {
            padding: 20px;
            background: linear-gradient(90deg, rgba(255, 0, 255, 0.2), rgba(0, 245, 255, 0.2));
            border-bottom: 1px solid var(--neon-pink);
        }

        .chat-header h3 {
            color: var(--neon-pink);
            margin-bottom: 10px;
        }

        .model-selector {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .model-btn {
            padding: 10px 20px;
            background: var(--bg-secondary);
            border: 2px solid var(--bg-tertiary);
            border-radius: 10px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .model-btn:hover {
            border-color: var(--neon-blue);
            color: var(--text-primary);
        }

        .model-btn.active {
            border-color: var(--neon-pink);
            color: var(--neon-pink);
            background: rgba(255, 0, 255, 0.1);
        }

        .model-btn.custom {
            border-color: var(--neon-orange);
            color: var(--neon-orange);
        }

        .chat-cost {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-top: 10px;
        }

        .chat-messages {
            height: 400px;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .chat-message {
            padding: 15px 20px;
            border-radius: 15px;
            max-width: 85%;
            animation: slideIn 0.3s ease-out;
            line-height: 1.6;
        }

        .chat-message.user {
            background: linear-gradient(135deg, var(--neon-blue), var(--neon-pink));
            align-self: flex-end;
        }

        .chat-message.ai {
            background: var(--bg-secondary);
            border: 1px solid var(--neon-pink);
            align-self: flex-start;
        }

        .chat-message pre {
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* Code block styling */
        .code-block-wrapper {
            position: relative;
            background: #1e1e2e;
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
        }

        .code-block {
            padding: 15px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            color: #e0e0e0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .code-copy-btn {
            position: fixed;
            padding: 8px 15px;
            background: var(--neon-green);
            color: black;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.8rem;
            z-index: 1000;
            pointer-events: auto;
            display: none;
            transition: all 0.2s ease;
        }

        .code-copy-btn:hover {
            transform: scale(1.1);
        }

        .chat-input-area {
            padding: 20px;
            display: flex;
            gap: 10px;
            border-top: 1px solid var(--bg-secondary);
            flex-wrap: wrap;
        }

        .chat-input {
            flex: 1;
            min-width: 200px;
            padding: 15px 20px;
            background: var(--bg-secondary);
            border: 2px solid var(--bg-tertiary);
            border-radius: 10px;
            color: var(--text-primary);
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .chat-input:focus {
            outline: none;
            border-color: var(--neon-pink);
        }

        .chat-send {
            padding: 15px 30px;
            background: linear-gradient(135deg, var(--neon-pink), var(--neon-blue));
            border: none;
            border-radius: 10px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .chat-send:hover {
            transform: scale(1.05);
        }

        .chat-send:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Custom Model Modal */
        .custom-model-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 600;
        }

        .custom-model-modal.active {
            display: flex;
        }

        .custom-model-content {
            background: var(--bg-secondary);
            padding: 40px;
            border-radius: 20px;
            border: 3px solid var(--neon-orange);
            max-width: 500px;
            width: 90%;
            text-align: center;
        }

        .custom-model-input {
            width: 100%;
            padding: 15px;
            background: var(--bg-tertiary);
            border: 2px solid var(--bg-tertiary);
            border-radius: 10px;
            color: var(--text-primary);
            font-size: 1rem;
            margin: 20px 0;
        }

        .custom-model-input:focus {
            outline: none;
            border-color: var(--neon-orange);
        }

        .blacklist-warning {
            color: var(--neon-pink);
            font-size: 0.8rem;
            margin-top: 10px;
        }

        /* Endgame */
        .endgame-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .endgame-modal.active {
            display: flex;
        }

        .endgame-content {
            text-align: center;
            animation: pulse 2s ease-in-out infinite;
        }

        .endgame-title {
            font-size: 4rem;
            background: linear-gradient(90deg, var(--neon-blue), var(--neon-pink), var(--neon-green));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 20px;
        }

        .endgame-subtitle {
            font-size: 1.5rem;
            color: var(--text-secondary);
            margin-bottom: 40px;
        }

        .endgame-choices {
            display: flex;
            gap: 30px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .endgame-choice {
            padding: 40px;
            background: var(--bg-tertiary);
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid transparent;
            max-width: 300px;
        }

        .endgame-choice:hover {
            transform: scale(1.05);
        }

        .endgame-choice.ai-choice {
            border-color: var(--neon-pink);
        }

        .endgame-choice.ai-choice:hover {
            box-shadow: 0 0 50px var(--neon-pink);
        }

        .endgame-choice.mine-choice {
            border-color: var(--neon-green);
        }

        .endgame-choice.mine-choice:hover {
            box-shadow: 0 0 50px var(--neon-green);
        }

        .choice-icon {
            font-size: 4rem;
            margin-bottom: 20px;
        }

        .choice-title {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .choice-desc {
            color: var(--text-secondary);
        }

        /* Ticker */
        .ticker {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--bg-secondary);
            padding: 10px 0;
            overflow: hidden;
            border-top: 1px solid var(--neon-blue);
        }

        .ticker-content {
            display: flex;
            animation: ticker 30s linear infinite;
            white-space: nowrap;
        }

        @keyframes ticker {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }

        .ticker-item {
            padding: 0 50px;
            color: var(--text-secondary);
        }

        .ticker-item span {
            color: var(--neon-blue);
        }

        /* Floating elements */
        .floating-joke {
            position: fixed;
            padding: 10px 20px;
            background: var(--bg-tertiary);
            border-radius: 10px;
            font-size: 0.8rem;
            color: var(--text-secondary);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease;
            z-index: 50;
        }

        .floating-joke.visible {
            opacity: 1;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(var(--neon-blue), var(--neon-pink));
            border-radius: 5px;
        }

        /* Patch Notes */
        .patch-notes {
            background: var(--bg-tertiary);
            padding: 20px;
            border-radius: 15px;
            margin-top: 30px;
            border-left: 4px solid var(--neon-orange);
        }

        .patch-title {
            color: var(--neon-orange);
            font-size: 1.2rem;
            margin-bottom: 15px;
        }

        .patch-item {
            padding: 5px 0;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .patch-item::before {
            content: '‚Ä¢ ';
            color: var(--neon-blue);
        }

        /* Reaction Game */
        .reaction-box {
            width: 200px;
            height: 200px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            transition: background 0.1s;
            cursor: pointer;
        }

        .reaction-box.waiting {
            background: #ff4444;
        }

        .reaction-box.ready {
            background: var(--neon-green);
        }

        /* Memory Game */
        .memory-grid {
            display: grid;
            grid-template-columns: repeat(4, 60px);
            gap: 10px;
            justify-content: center;
        }

        .memory-tile {
            width: 60px;
            height: 60px;
            background: var(--bg-tertiary);
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            transition: all 0.3s ease;
            border: 2px solid var(--bg-secondary);
        }

        .memory-tile.revealed {
            background: var(--neon-blue);
            border-color: var(--neon-blue);
        }

        .memory-tile.matched {
            background: var(--neon-green);
            border-color: var(--neon-green);
        }

        /* Dodge Game */
        .dodge-area {
            width: 300px;
            height: 300px;
            background: var(--bg-tertiary);
            border-radius: 15px;
            position: relative;
            overflow: hidden;
            cursor: none;
        }

        .dodge-player {
            width: 30px;
            height: 30px;
            background: var(--neon-green);
            border-radius: 50%;
            position: absolute;
            transition: all 0.05s ease;
            box-shadow: 0 0 20px var(--neon-green);
        }

        .dodge-block {
            width: 40px;
            height: 40px;
            background: var(--neon-pink);
            position: absolute;
            border-radius: 5px;
            box-shadow: 0 0 15px var(--neon-pink);
        }

        /* Lucky Wheel */
        .wheel-container {
            position: relative;
            width: 250px;
            height: 250px;
        }

        .wheel {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: conic-gradient(
                var(--neon-blue) 0deg 45deg,
                var(--neon-pink) 45deg 90deg,
                var(--neon-green) 90deg 135deg,
                var(--neon-orange) 135deg 180deg,
                var(--neon-yellow) 180deg 225deg,
                var(--neon-blue) 225deg 270deg,
                var(--neon-pink) 270deg 315deg,
                var(--neon-green) 315deg 360deg
            );
            transition: transform 4s cubic-bezier(0.17, 0.67, 0.12, 0.99);
            box-shadow: 0 0 30px rgba(0, 245, 255, 0.5);
        }

        .wheel-pointer {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 2rem;
        }

        /* Math Game */
        .math-problem {
            font-size: 3rem;
            color: var(--neon-blue);
            margin: 20px 0;
        }

        .math-input {
            font-size: 2rem;
            padding: 10px 20px;
            width: 150px;
            text-align: center;
            background: var(--bg-secondary);
            border: 2px solid var(--neon-blue);
            border-radius: 10px;
            color: var(--text-primary);
        }

        /* Slider Game */
        .precision-slider {
            width: 300px;
            height: 40px;
            background: linear-gradient(90deg, 
                var(--neon-pink) 0%, 
                var(--neon-pink) 45%, 
                var(--neon-green) 45%, 
                var(--neon-green) 55%, 
                var(--neon-pink) 55%, 
                var(--neon-pink) 100%
            );
            border-radius: 20px;
            position: relative;
            cursor: pointer;
        }

        .slider-marker {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 10px;
            height: 50px;
            background: white;
            border-radius: 5px;
            transition: left 0.05s linear;
        }

        /* Infinity indicator */
        .infinity-active {
            position: fixed;
            bottom: 50px;
            right: 20px;
            padding: 15px 25px;
            background: var(--bg-tertiary);
            border: 2px solid var(--neon-green);
            border-radius: 15px;
            animation: glow 2s ease-in-out infinite;
        }

        .infinity-active span {
            color: var(--neon-green);
        }

        /* Unlimited AI badge */
        .unlimited-badge {
            display: inline-block;
            padding: 5px 15px;
            background: linear-gradient(90deg, var(--neon-pink), var(--neon-blue));
            border-radius: 20px;
            font-size: 0.8rem;
            margin-left: 10px;
            animation: rainbow 2s linear infinite;
        }

        /* Toast notifications */
        .toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            padding: 15px 30px;
            background: var(--bg-tertiary);
            border: 2px solid var(--neon-green);
            border-radius: 15px;
            opacity: 0;
            transition: all 0.5s ease;
            z-index: 1000;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* Subway Surfers style game */
        .subway-game {
            width: 300px;
            height: 400px;
            background: linear-gradient(180deg, #87CEEB 0%, #228B22 100%);
            border-radius: 15px;
            position: relative;
            overflow: hidden;
        }

        .subway-player {
            width: 40px;
            height: 60px;
            background: var(--neon-blue);
            position: absolute;
            bottom: 50px;
            border-radius: 10px;
            transition: left 0.2s ease;
        }

        .subway-obstacle {
            width: 60px;
            height: 40px;
            background: var(--neon-pink);
            position: absolute;
            border-radius: 5px;
        }

        .subway-coin {
            width: 20px;
            height: 20px;
            background: gold;
            border-radius: 50%;
            position: absolute;
        }

        .subway-lanes {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 50px;
            background: #333;
            display: flex;
        }

        .subway-lane {
            flex: 1;
            border-right: 2px dashed #555;
        }

        /* FNF style game */
        .fnf-game {
            width: 400px;
            height: 400px;
            background: #1a1a2e;
            border-radius: 15px;
            position: relative;
            overflow: hidden;
        }

        .fnf-lanes {
            display: flex;
            justify-content: center;
            gap: 10px;
            height: 100%;
            padding: 20px;
        }

        .fnf-lane {
            width: 60px;
            height: 100%;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            position: relative;
        }

        .fnf-target {
            position: absolute;
            bottom: 20px;
            left: 5px;
            right: 5px;
            height: 30px;
            background: rgba(255,255,255,0.3);
            border-radius: 5px;
            border: 2px solid white;
        }

        .fnf-note {
            position: absolute;
            left: 5px;
            right: 5px;
            height: 30px;
            border-radius: 5px;
        }

        .fnf-note.left { background: #ff6b6b; }
        .fnf-note.down { background: #4ecdc4; }
        .fnf-note.up { background: #45b7d1; }
        .fnf-note.right { background: #96ceb4; }

        .fnf-keys {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .fnf-key {
            padding: 15px 25px;
            background: var(--bg-tertiary);
            border: 2px solid var(--neon-blue);
            border-radius: 10px;
            color: white;
            font-weight: bold;
        }

        .fnf-key.active {
            background: var(--neon-blue);
            color: black;
        }

        /* Snake Game */
        .snake-game {
            width: 300px;
            height: 300px;
            background: var(--bg-tertiary);
            border-radius: 15px;
            position: relative;
        }

        .snake-segment {
            width: 15px;
            height: 15px;
            background: var(--neon-green);
            position: absolute;
            border-radius: 3px;
        }

        .snake-food {
            width: 15px;
            height: 15px;
            background: var(--neon-pink);
            position: absolute;
            border-radius: 50%;
        }

        /* Flappy Bird style */
        .flappy-game {
            width: 300px;
            height: 400px;
            background: linear-gradient(180deg, #87CEEB 0%, #98D8C8 100%);
            border-radius: 15px;
            position: relative;
            overflow: hidden;
        }

        .flappy-bird {
            width: 30px;
            height: 30px;
            background: yellow;
            position: absolute;
            border-radius: 50%;
            left: 50px;
        }

        .flappy-pipe {
            width: 50px;
            background: green;
            position: absolute;
        }

        /* Pong Game */
        .pong-game {
            width: 400px;
            height: 300px;
            background: #000;
            border-radius: 15px;
            position: relative;
        }

        .pong-paddle {
            width: 10px;
            height: 60px;
            background: white;
            position: absolute;
        }

        .pong-ball {
            width: 15px;
            height: 15px;
            background: white;
            position: absolute;
            border-radius: 50%;
        }

        /* Breakout */
        .breakout-game {
            width: 400px;
            height: 400px;
            background: var(--bg-tertiary);
            border-radius: 15px;
            position: relative;
            overflow: hidden;
        }

        .breakout-paddle {
            width: 80px;
            height: 15px;
            background: var(--neon-blue);
            position: absolute;
            bottom: 20px;
            border-radius: 5px;
        }

        .breakout-ball {
            width: 12px;
            height: 12px;
            background: white;
            position: absolute;
            border-radius: 50%;
        }

        .breakout-brick {
            width: 45px;
            height: 20px;
            position: absolute;
            border-radius: 3px;
        }

        /* Typing Game */
        .typing-word {
            font-size: 2rem;
            color: var(--neon-blue);
            margin: 20px 0;
            letter-spacing: 5px;
        }

        .typing-input {
            font-size: 1.5rem;
            padding: 15px 30px;
            background: var(--bg-secondary);
            border: 2px solid var(--neon-blue);
            border-radius: 10px;
            color: var(--text-primary);
            text-align: center;
            width: 300px;
        }

        /* Color Match */
        .color-display {
            font-size: 3rem;
            font-weight: bold;
            padding: 30px 60px;
            border-radius: 15px;
            margin: 20px 0;
        }

        .color-buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .color-btn {
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .color-btn:hover {
            transform: scale(1.1);
        }

        /* Aim Trainer */
        .aim-game {
            width: 400px;
            height: 400px;
            background: var(--bg-tertiary);
            border-radius: 15px;
            position: relative;
            cursor: crosshair;
        }

        .aim-target {
            width: 50px;
            height: 50px;
            background: radial-gradient(circle, var(--neon-pink) 30%, transparent 30%, transparent 50%, var(--neon-pink) 50%, var(--neon-pink) 70%, transparent 70%);
            border: 3px solid var(--neon-pink);
            border-radius: 50%;
            position: absolute;
            cursor: pointer;
        }

        /* 2048 style */
        .game-2048 {
            display: grid;
            grid-template-columns: repeat(4, 70px);
            gap: 10px;
            padding: 10px;
            background: var(--bg-tertiary);
            border-radius: 15px;
        }

        .tile-2048 {
            width: 70px;
            height: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            border-radius: 10px;
            background: var(--bg-secondary);
            transition: all 0.1s ease;
        }

        /* Cheat notification */
        .cheat-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 40px 60px;
            background: linear-gradient(135deg, var(--neon-pink), var(--neon-blue));
            border-radius: 20px;
            font-size: 2rem;
            font-weight: bold;
            z-index: 2000;
            animation: pulse 0.5s ease-in-out infinite;
            display: none;
        }

        .cheat-popup.show {
            display: block;
        }
    </style>
</head>
<body>
    <!-- Initial Mining Screen -->
    <div id="initial-mining">
        <h1 class="mining-title">‚õèÔ∏è AIR ORE ‚õèÔ∏è</h1>
        <p class="mining-subtitle">Mining air since 2026‚Ñ¢ - Click the rock to begin your journey</p>
        
        <div class="ore-rock" id="initialRock">
            <div class="ore-veins"></div>
        </div>
        
        <div class="mining-progress">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <p class="progress-text"><span id="mineCount">0</span>/10 Air Ore Mined</p>
        </div>
        
        <p style="margin-top: 30px; color: var(--text-secondary); font-size: 0.9rem;">
            ‚ö†Ô∏è WARNING: This ore is lighter than your responsibilities
        </p>
    </div>

    <!-- Bouncing Popup (hidden initially) -->
    <div class="bouncing-popup" id="bouncingPopup" style="display: none;">
        <h2>üéâ UNLOCKED! üéâ</h2>
        <p>You are now a certified Air Miner!</p>
        <p style="font-size: 0.8rem; color: var(--text-secondary);">This popup has physics btw</p>
    </div>

    <!-- Main App -->
    <div id="main-app">
        <!-- Top Bar -->
        <div class="top-bar">
            <div class="logo" onclick="showJoke()">üí® AIR ORE</div>
            <div class="ore-display">
                <div class="ore-counter">
                    <span class="ore-icon">üíé</span>
                    <span class="ore-amount" id="oreDisplay">0</span>
                </div>
                <div class="ore-counter diamond">
                    <span class="ore-icon">üí†</span>
                    <span class="ore-amount" id="diamondDisplay">0</span>
                </div>
                <div class="ore-counter gems">
                    <span class="ore-icon">üíé</span>
                    <span class="ore-amount" id="gemsDisplay">0</span>
                    <span style="font-size: 0.8rem; color: var(--neon-pink);">gems</span>
                </div>
            </div>
        </div>

        <!-- Navigation -->
        <div class="nav-tabs">
            <div class="nav-tab active" data-tab="mine">‚õèÔ∏è Mine</div>
            <div class="nav-tab" data-tab="minigames">üéÆ Minigames</div>
            <div class="nav-tab" data-tab="upgrades">‚¨ÜÔ∏è Upgrades</div>
            <div class="nav-tab" data-tab="chat">ü§ñ AI Chat</div>
        </div>

        <!-- Mine Section -->
        <div class="content-section active" id="mine">
            <h2 class="section-title">‚õèÔ∏è The Infinite Mine ‚õèÔ∏è</h2>
            
            <div class="mine-container">
                <div class="big-ore" id="bigOre">
                    <div class="ore-sparkles">
                        <div class="sparkle" style="top: 20%; left: 30%;"></div>
                        <div class="sparkle" style="top: 60%; left: 70%;"></div>
                        <div class="sparkle" style="top: 40%; left: 20%;"></div>
                        <div class="sparkle" style="top: 80%; left: 50%;"></div>
                    </div>
                </div>
                
                <p style="color: var(--text-secondary);">Click to mine! Each click = <span id="orePerClick">1</span> ore</p>
                
                <div class="mine-stats">
                    <div class="stat-card">
                        <div class="stat-value" id="totalMined">0</div>
                        <div class="stat-label">Total Mined</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="clickPower">1</div>
                        <div class="stat-label">Click Power</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="autoMine">0</div>
                        <div class="stat-label">Auto Mine/sec</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="diamondChance">1%</div>
                        <div class="stat-label">Diamond Chance</div>
                    </div>
                </div>
            </div>
            
            <div class="patch-notes">
                <h3 class="patch-title">üìã PATCH NOTES v0.0.0.0.2 (THE AI UPDATE)</h3>
                <div class="patch-item">Added REAL AI chat with 3 model choices!</div>
                <div class="patch-item">Added 10 NEW minigames including Subway Surfers & FNF clones!</div>
                <div class="patch-item">Added gems currency for custom AI models</div>
                <div class="patch-item">Message costs now scale: 30‚Üí60‚Üí120‚Üí300 ore</div>
                <div class="patch-item">Added secret cheat code (we won't tell you what it is üëÄ)</div>
                <div class="patch-item">AI responses now have copy buttons that follow your mouse!</div>
            </div>
        </div>

        <!-- Minigames Section -->
        <div class="content-section" id="minigames">
            <h2 class="section-title">üéÆ Minigames üéÆ</h2>
            <p style="text-align: center; color: var(--text-secondary); margin-bottom: 30px;">
                Play games. Get ore. Question your life choices.
            </p>
            
            <div class="minigames-grid">
                <div class="minigame-card featured" data-game="subway">
                    <span class="featured-badge">‚≠ê FEATURED</span>
                    <div class="minigame-icon">üèÉ</div>
                    <div class="minigame-name">Air Surfers</div>
                    <div class="minigame-reward">Reward: 50 ore/100m + coins</div>
                </div>

                <div class="minigame-card featured" data-game="fnf">
                    <span class="featured-badge">‚≠ê FEATURED</span>
                    <div class="minigame-icon">üé§</div>
                    <div class="minigame-name">Friday Night Minin'</div>
                    <div class="minigame-reward">Reward: 25 ore/note</div>
                </div>
                
                <div class="minigame-card" data-game="reaction">
                    <div class="minigame-icon">‚ö°</div>
                    <div class="minigame-name">Reaction Test</div>
                    <div class="minigame-reward">Reward: 50-200 ore</div>
                </div>
                
                <div class="minigame-card" data-game="memory">
                    <div class="minigame-icon">üß†</div>
                    <div class="minigame-name">Memory Match</div>
                    <div class="minigame-reward">Reward: 100-500 ore</div>
                </div>
                
                <div class="minigame-card" data-game="dodge">
                    <div class="minigame-icon">üöó</div>
                    <div class="minigame-name">Dodge Blocks</div>
                    <div class="minigame-reward">Reward: 10 ore/sec survived</div>
                </div>
                
                <div class="minigame-card" data-game="speedclick">
                    <div class="minigame-icon">üëÜ</div>
                    <div class="minigame-name">Speed Click</div>
                    <div class="minigame-reward">Reward: 5 ore/click</div>
                </div>
                
                <div class="minigame-card" data-game="rhythm">
                    <div class="minigame-icon">üéµ</div>
                    <div class="minigame-name">Rhythm Tap</div>
                    <div class="minigame-reward">Reward: 20 ore/perfect</div>
                </div>
                
                <div class="minigame-card" data-game="math">
                    <div class="minigame-icon">üî¢</div>
                    <div class="minigame-name">Math Rush</div>
                    <div class="minigame-reward">Reward: 100 ore/correct</div>
                </div>
                
                <div class="minigame-card" data-game="slider">
                    <div class="minigame-icon">üéØ</div>
                    <div class="minigame-name">Precision Stop</div>
                    <div class="minigame-reward minigame-diamond">üí† Diamond chance!</div>
                </div>
                
                <div class="minigame-card" data-game="wheel">
                    <div class="minigame-icon">üé∞</div>
                    <div class="minigame-name">Lucky Wheel</div>
                    <div class="minigame-reward minigame-diamond">üí† Up to 5 diamonds!</div>
                </div>
                
                <div class="minigame-card" data-game="boss">
                    <div class="minigame-icon">üëπ</div>
                    <div class="minigame-name">Mini Boss</div>
                    <div class="minigame-reward minigame-diamond">üí† Guaranteed diamond!</div>
                </div>

                <div class="minigame-card" data-game="snake">
                    <div class="minigame-icon">üêç</div>
                    <div class="minigame-name">Air Snake</div>
                    <div class="minigame-reward">Reward: 10 ore/food</div>
                </div>

                <div class="minigame-card" data-game="flappy">
                    <div class="minigame-icon">üê¶</div>
                    <div class="minigame-name">Flappy Ore</div>
                    <div class="minigame-reward">Reward: 20 ore/pipe</div>
                </div>

                <div class="minigame-card" data-game="pong">
                    <div class="minigame-icon">üèì</div>
                    <div class="minigame-name">Air Pong</div>
                    <div class="minigame-reward">Reward: 30 ore/point</div>
                </div>

                <div class="minigame-card" data-game="breakout">
                    <div class="minigame-icon">üß±</div>
                    <div class="minigame-name">Ore Breaker</div>
                    <div class="minigame-reward">Reward: 5 ore/brick</div>
                </div>

                <div class="minigame-card" data-game="typing">
                    <div class="minigame-icon">‚å®Ô∏è</div>
                    <div class="minigame-name">Type Rush</div>
                    <div class="minigame-reward">Reward: 50 ore/word</div>
                </div>

                <div class="minigame-card" data-game="colorMatch">
                    <div class="minigame-icon">üé®</div>
                    <div class="minigame-name">Color Chaos</div>
                    <div class="minigame-reward">Reward: 40 ore/correct</div>
                </div>

                <div class="minigame-card" data-game="aim">
                    <div class="minigame-icon">üéØ</div>
                    <div class="minigame-name">Aim Trainer</div>
                    <div class="minigame-reward">Reward: 15 ore/hit</div>
                </div>

                <div class="minigame-card" data-game="2048">
                    <div class="minigame-icon">üî¢</div>
                    <div class="minigame-name">2048 Ore</div>
                    <div class="minigame-reward minigame-diamond">üí† Diamond at 2048!</div>
                </div>
            </div>
        </div>

        <!-- Upgrades Section -->
        <div class="content-section" id="upgrades">
            <h2 class="section-title">‚¨ÜÔ∏è Upgrades ‚¨ÜÔ∏è</h2>
            <p style="text-align: center; color: var(--text-secondary); margin-bottom: 30px;">
                Spend ore to get more ore. It's like capitalism but with air.
            </p>
            
            <div class="upgrades-grid" id="upgradesGrid">
                <!-- Upgrades will be generated by JS -->
            </div>
        </div>

        <!-- AI Chat Section -->
        <div class="content-section" id="chat">
            <h2 class="section-title">ü§ñ AI Chat ü§ñ</h2>
            
            <div class="chat-container">
                <div class="chat-header">
                    <h3>AirBot 3000 <span class="unlimited-badge" id="unlimitedBadge" style="display: none;">‚àû UNLIMITED</span></h3>
                    
                    <div class="model-selector">
                        <button class="model-btn active" data-model="anthropic/claude-opus-4.5">üü£ Claude Opus 4.5</button>
                        <button class="model-btn" data-model="openai/gpt-5.2">üü¢ GPT-5.2</button>
                        <button class="model-btn" data-model="google/gemini-3-pro-preview">üîµ Gemini 3 Pro</button>
                        <button class="model-btn custom" id="customModelBtn">üíé Custom (10 gems)</button>
                    </div>
                    
                    <p class="chat-cost" id="chatCost">Message cost: <span id="currentCost">30</span> ore (Messages sent: <span id="messageCount">0</span>)</p>
                </div>
                
                <div class="chat-messages" id="chatMessages">
                    <div class="chat-message ai">
                        Each message costs ore (30‚Üí60‚Üí120‚Üí300 after every 3 messages) so grind up you rizzler.
                    </div>
                </div>
                
                <div class="chat-input-area">
                    <input type="text" class="chat-input" id="chatInput" placeholder="Ask the AI anything...">
                    <button class="chat-send" id="chatSend">Send (<span id="sendCost">30</span>üíé)</button>
                </div>
            </div>
        </div>

        <!-- Ticker -->
        <div class="ticker">
            <div class="ticker-content">
                <span class="ticker-item">üö® BREAKING: <span>Air prices hit all-time high</span></span>
                <span class="ticker-item">üìà <span>ORE/USD:</span> $0.000001 (+‚àû%)</span>
                <span class="ticker-item">ü§ñ <span>NEW: Real AI integration!</span> Claude, GPT, Gemini available</span>
                <span class="ticker-item">üéÆ <span>20 Minigames now available!</span> Including Subway Surfers & FNF clones</span>
                <span class="ticker-item">üí° TIP: <span>Try the secret cheat code...</span></span>
                <span class="ticker-item">üîí Your data is stored in <span>localStorage</span>. Very secure. Trust us.</span>
                <span class="ticker-item">üö® BREAKING: <span>Air prices hit all-time high</span></span>
                <span class="ticker-item">üìà <span>ORE/USD:</span> $0.000001 (+‚àû%)</span>
                <span class="ticker-item">ü§ñ <span>NEW: Real AI integration!</span> Claude, GPT, Gemini available</span>
                <span class="ticker-item">üéÆ <span>20 Minigames now available!</span> Including Subway Surfers & FNF clones</span>
            </div>
        </div>
    </div>

    <!-- Game Modal -->
    <div class="game-modal" id="gameModal">
        <div class="game-container" id="gameContainer">
            <span class="game-close" id="gameClose">√ó</span>
            <h2 class="game-title" id="gameTitle">Game</h2>
            <div class="game-area" id="gameArea">
                <!-- Game content loaded dynamically -->
            </div>
        </div>
    </div>

    <!-- Custom Model Modal -->
    <div class="custom-model-modal" id="customModelModal">
        <div class="custom-model-content">
            <h2 style="color: var(--neon-orange); margin-bottom: 20px;">üíé Custom Model</h2>
            <p>Cost: <strong>1000 gems</strong></p>
            <p style="color: var(--text-secondary); margin-top: 10px;">Your gems: <span id="modalGems">0</span></p>
            <input type="text" class="custom-model-input" id="customModelInput" placeholder="e.g., meta/llama-3.1-405b">
            <p class="blacklist-warning">‚ö†Ô∏è Blacklisted models: openai/gpt-5.2-pro, openai/gpt-5-pro</p>
            <div style="display: flex; gap: 15px; justify-content: center; margin-top: 20px;">
                <button class="game-btn" style="padding: 15px 30px; font-size: 1rem;" id="buyCustomModel">Buy & Use</button>
                <button class="game-btn" style="padding: 15px 30px; font-size: 1rem; background: var(--bg-tertiary);" id="closeCustomModal">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Endgame Modal -->
    <div class="endgame-modal" id="endgameModal">
        <div class="endgame-content">
            <h1 class="endgame-title">üåü PEAK AIR ACHIEVED üåü</h1>
            <p class="endgame-subtitle">You have mined 100,000 ore. The air bows before you.</p>
            <p style="color: var(--text-secondary); margin-bottom: 30px;">Choose your destiny:</p>
            
            <div class="endgame-choices">
                <div class="endgame-choice ai-choice" data-choice="ai">
                    <div class="choice-icon">ü§ñ</div>
                    <div class="choice-title">Unlimited AI</div>
                    <div class="choice-desc">Free AI chat forever. No more ore costs.</div>
                </div>
                
                <div class="endgame-choice mine-choice" data-choice="infinity">
                    <div class="choice-icon">‚ôæÔ∏è</div>
                    <div class="choice-title">Infinity Mine</div>
                    <div class="choice-desc">Auto-generate 100 ore per second forever.</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Floating Joke -->
    <div class="floating-joke" id="floatingJoke"></div>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <!-- Cheat Popup -->
    <div class="cheat-popup" id="cheatPopup">üéâ +5000 GEMS! üéâ</div>

    <!-- Infinity Active Indicator -->
    <div class="infinity-active" id="infinityIndicator" style="display: none;">
        ‚ôæÔ∏è <span>+100/sec</span>
    </div>

    <!-- Floating Copy Button -->
    <button class="code-copy-btn" id="floatingCopyBtn">üìã Copy</button>

    <script>
        // API Configuration
        const API_BASE_URL = "https://epistolic-colette-decently.ngrok-free.dev";
        
        // Blacklisted models
        const BLACKLISTED_MODELS = ["openai/gpt-5.2-pro", "openai/gpt-5-pro"];
        
        // Available models
        const AVAILABLE_MODELS = [
            "anthropic/claude-opus-4.5",
            "openai/gpt-5.2",
            "google/gemini-3-pro-preview"
        ];

        // Cost progression: [30, 30, 30, 60, 60, 60, 120, 120, 120, 300, 300, 300, ...]
        function getMessageCost(messageCount) {
            if (messageCount < 3) return 30;
            if (messageCount < 6) return 60;
            if (messageCount < 9) return 120;
            return 300;
        }

        // Game State
        let gameState = {
            ore: 0,
            diamondOre: 0,
            gems: 0,
            totalMined: 0,
            clickPower: 1,
            autoMine: 0,
            diamondChance: 1,
            upgrades: {},
            hasCompletedIntro: false,
            endgameChoice: null,
            unlimitedAI: false,
            infinityMine: false,
            messageCount: 0,
            selectedModel: "anthropic/claude-opus-4.5",
            customModel: null,
            userId: 'user_' + Math.random().toString(36).substr(2, 9)
        };

        // Cheat code detection
        let cheatBuffer = '';
        const CHEAT_CODE = 'iamadirtycheater';

        document.addEventListener('keypress', (e) => {
            cheatBuffer += e.key.toLowerCase();
            if (cheatBuffer.length > CHEAT_CODE.length) {
                cheatBuffer = cheatBuffer.slice(-CHEAT_CODE.length);
            }
            if (cheatBuffer === CHEAT_CODE) {
                activateCheat();
                cheatBuffer = '';
            }
        });

        function activateCheat() {
            gameState.gems += 500;
            gameState.ore += 15000;
            updateDisplays();
            saveGame();
            
            const popup = document.getElementById('cheatPopup');
            popup.classList.add('show');
            setTimeout(() => popup.classList.remove('show'), 2000);
            showToast('üéÆ Cheat activated! +5000 gems!');
        }

        // Load saved state
        function loadGame() {
            const saved = localStorage.getItem('airOreStateV2');
            if (saved) {
                gameState = { ...gameState, ...JSON.parse(saved) };
            }
        }

        // Save state
        function saveGame() {
            localStorage.setItem('airOreStateV2', JSON.stringify(gameState));
        }

        // Update displays
        function updateDisplays() {
            document.getElementById('oreDisplay').textContent = formatNumber(gameState.ore);
            document.getElementById('diamondDisplay').textContent = formatNumber(gameState.diamondOre);
            document.getElementById('gemsDisplay').textContent = formatNumber(gameState.gems);
            document.getElementById('totalMined').textContent = formatNumber(gameState.totalMined);
            document.getElementById('clickPower').textContent = gameState.clickPower;
            document.getElementById('autoMine').textContent = gameState.autoMine;
            document.getElementById('diamondChance').textContent = gameState.diamondChance + '%';
            document.getElementById('orePerClick').textContent = gameState.clickPower;
            
            // Update chat costs
            const currentCost = gameState.unlimitedAI ? 0 : getMessageCost(gameState.messageCount);
            document.getElementById('currentCost').textContent = currentCost;
            document.getElementById('sendCost').textContent = currentCost;
            document.getElementById('messageCount').textContent = gameState.messageCount;
            document.getElementById('modalGems').textContent = gameState.gems;
            
            if (gameState.unlimitedAI) {
                document.getElementById('chatCost').textContent = '‚ú® UNLIMITED - Chat for free forever! ‚ú®';
                document.getElementById('chatSend').textContent = 'Send (FREE!)';
            }
            
            // Check for endgame
            if (gameState.ore >= 100000 && !gameState.endgameChoice) {
                showEndgame();
            }
        }

        function formatNumber(num) {
            if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
            if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
            return Math.floor(num).toString();
        }

        // Particle system
        function createParticle(x, y, emoji = '‚ú®') {
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.textContent = emoji;
            particle.style.left = x + 'px';
            particle.style.top = y + 'px';
            document.body.appendChild(particle);
            setTimeout(() => particle.remove(), 1000);
        }

        function createMultipleParticles(x, y, count = 5) {
            const emojis = ['‚ú®', 'üíé', '‚≠ê', 'üí´', 'üåü'];
            for (let i = 0; i < count; i++) {
                setTimeout(() => {
                    const offsetX = (Math.random() - 0.5) * 100;
                    const offsetY = (Math.random() - 0.5) * 100;
                    createParticle(x + offsetX, y + offsetY, emojis[Math.floor(Math.random() * emojis.length)]);
                }, i * 50);
            }
        }

        // Screen shake
        function screenShake() {
            document.body.classList.add('shake');
            setTimeout(() => document.body.classList.remove('shake'), 100);
        }

        // Toast notification
        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }

        // Initial mining sequence
        let initialOre = 0;
        const initialRock = document.getElementById('initialRock');
        const progressFill = document.getElementById('progressFill');
        const mineCount = document.getElementById('mineCount');

        if (initialRock) {
            initialRock.addEventListener('click', function(e) {
                if (gameState.hasCompletedIntro) return;
                
                initialOre++;
                mineCount.textContent = initialOre;
                progressFill.style.width = (initialOre * 10) + '%';
                
                createMultipleParticles(e.clientX, e.clientY, 3);
                screenShake();
                
                this.style.transform = 'scale(0.95)';
                setTimeout(() => this.style.transform = '', 100);
                
                if (initialOre >= 10) {
                    completeIntro();
                }
            });
        }

        function completeIntro() {
            gameState.hasCompletedIntro = true;
            gameState.ore = 10;
            gameState.totalMined = 10;
            saveGame();
            
            // Show bouncing popup
            const popup = document.getElementById('bouncingPopup');
            popup.style.display = 'block';
            
            // Physics simulation
            let x = window.innerWidth / 2 - 100;
            let y = window.innerHeight / 2 - 50;
            let vx = (Math.random() - 0.5) * 10;
            let vy = -15;
            let rotation = 0;
            let rotationSpeed = 10;
            const gravity = 0.5;
            const bounce = 0.7;
            const friction = 0.99;
            
            let bounceCount = 0;
            
            function animatePopup() {
                vy += gravity;
                x += vx;
                y += vy;
                rotation += rotationSpeed;
                
                vx *= friction;
                rotationSpeed *= 0.99;
                
                if (x < 0) { x = 0; vx = -vx * bounce; bounceCount++; }
                if (x > window.innerWidth - 200) { x = window.innerWidth - 200; vx = -vx * bounce; bounceCount++; }
                if (y > window.innerHeight - 100) { 
                    y = window.innerHeight - 100; 
                    vy = -vy * bounce; 
                    bounceCount++;
                    rotationSpeed = vx * 2;
                }
                
                popup.style.left = x + 'px';
                popup.style.top = y + 'px';
                popup.style.transform = `rotate(${rotation}deg)`;
                
                if (bounceCount < 8) {
                    requestAnimationFrame(animatePopup);
                } else {
                    popup.style.transition = 'all 2s ease-in';
                    popup.style.transform = `translateY(200vh) rotate(1440deg)`;
                    popup.style.opacity = '0';
                    
                    setTimeout(() => {
                        popup.remove();
                        showMainApp();
                    }, 2000);
                }
            }
            
            animatePopup();
        }

        function showMainApp() {
            document.getElementById('initial-mining').classList.add('hidden');
            document.getElementById('main-app').classList.add('visible');
            updateDisplays();
            generateUpgrades();
            
            if (gameState.infinityMine) {
                document.getElementById('infinityIndicator').style.display = 'block';
            }
            
            if (gameState.unlimitedAI) {
                document.getElementById('unlimitedBadge').style.display = 'inline-block';
            }
            
            // Update model selection
            document.querySelectorAll('.model-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.model === gameState.selectedModel) {
                    btn.classList.add('active');
                }
            });
        }

        // Main mining click
        const bigOre = document.getElementById('bigOre');
        if (bigOre) {
            bigOre.addEventListener('click', function(e) {
                const earned = gameState.clickPower;
                gameState.ore += earned;
                gameState.totalMined += earned;
                
                // Diamond chance
                if (Math.random() * 100 < gameState.diamondChance) {
                    gameState.diamondOre++;
                    createParticle(e.clientX, e.clientY, 'üí†');
                    showToast('üí† DIAMOND ORE!');
                }
                
                // Gem chance (1%)
                if (Math.random() < 0.01) {
                    gameState.gems++;
                    createParticle(e.clientX, e.clientY, 'üíé');
                    showToast('üíé GEM FOUND!');
                }
                
                createMultipleParticles(e.clientX, e.clientY, 3);
                screenShake();
                updateDisplays();
                saveGame();
            });
        }

        // Navigation
        document.querySelectorAll('.nav-tab').forEach(tab => {
            tab.addEventListener('click', function() {
                document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.content-section').forEach(s => s.classList.remove('active'));
                
                this.classList.add('active');
                document.getElementById(this.dataset.tab).classList.add('active');
            });
        });

        // Model selection
        document.querySelectorAll('.model-btn:not(#customModelBtn)').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.model-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                gameState.selectedModel = this.dataset.model;
                saveGame();
                showToast(`ü§ñ Model switched to ${this.dataset.model.split('/')[1]}`);
            });
        });

        // Custom model
        document.getElementById('customModelBtn').addEventListener('click', () => {
            document.getElementById('customModelModal').classList.add('active');
            document.getElementById('modalGems').textContent = gameState.gems;
        });

        document.getElementById('closeCustomModal').addEventListener('click', () => {
            document.getElementById('customModelModal').classList.remove('active');
        });

        document.getElementById('buyCustomModel').addEventListener('click', () => {
            const modelName = document.getElementById('customModelInput').value.trim();
            
            if (!modelName) {
                showToast('‚ùå Please enter a model name');
                return;
            }
            
            if (BLACKLISTED_MODELS.includes(modelName)) {
                showToast('‚ùå This model is blacklisted!');
                return;
            }
            
            if (gameState.gems < 100) {
                showToast('‚ùå Not enough gems! Need 10');
                return;
            }
            
            gameState.gems -= 10;
            gameState.customModel = modelName;
            gameState.selectedModel = modelName;
            
            // Update UI
            document.querySelectorAll('.model-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('customModelBtn').classList.add('active');
            document.getElementById('customModelBtn').textContent = `üíé ${modelName.split('/')[1] || modelName}`;
            
            document.getElementById('customModelModal').classList.remove('active');
            updateDisplays();
            saveGame();
            showToast(`ü§ñ Custom model activated: ${modelName}`);
        });

        // Upgrades system
        const upgradeData = [
            { id: 'pickaxe1', name: 'Better Pickaxe', desc: 'Your pickaxe is now slightly less terrible', cost: 100, effect: () => gameState.clickPower += 1, icon: '‚õèÔ∏è' },
            { id: 'pickaxe2', name: 'Golden Pickaxe', desc: 'It\'s shiny. That\'s it.', cost: 500, effect: () => gameState.clickPower += 5, icon: 'ü•á' },
            { id: 'pickaxe3', name: 'Diamond Pickaxe', desc: 'Minecraft would be proud', cost: 2000, effect: () => gameState.clickPower += 15, icon: 'üíé' },
            { id: 'auto1', name: 'Tiny Robot', desc: 'A small robot that mines while you sleep', cost: 1000, effect: () => gameState.autoMine += 1, icon: 'ü§ñ' },
            { id: 'auto2', name: 'Robot Army', desc: 'Many small robots. They judge you.', cost: 5000, effect: () => gameState.autoMine += 5, icon: 'ü¶æ' },
            { id: 'auto3', name: 'AI Overlord', desc: 'The AI is now in charge.', cost: 20000, effect: () => gameState.autoMine += 20, icon: 'üß†' },
            { id: 'luck1', name: 'Lucky Charm', desc: '+1% diamond chance', cost: 3000, effect: () => gameState.diamondChance += 1, icon: 'üçÄ' },
            { id: 'luck2', name: 'Luckier Charm', desc: '+2% more luck', cost: 10000, effect: () => gameState.diamondChance += 2, icon: 'üé∞' },
            { id: 'luck3', name: 'Luckiest Charm', desc: '+5% luck', cost: 30000, effect: () => gameState.diamondChance += 5, icon: 'üåà' },
            { id: 'mega1', name: 'Mega Miner', desc: 'x2 click power', cost: 50000, effect: () => gameState.clickPower *= 2, icon: 'üí™' },
            { id: 'gems1', name: 'Gem Finder', desc: '+2% gem chance per click', cost: 75000, effect: () => {}, icon: 'üíé' },
            { id: 'fake1', name: 'Air NFT', desc: 'You now own a picture of air.', cost: 42069, effect: () => showToast('üñºÔ∏è Right-click saved!'), icon: 'üñºÔ∏è' },
        ];

        function generateUpgrades() {
            const grid = document.getElementById('upgradesGrid');
            grid.innerHTML = '';
            
            upgradeData.forEach(upgrade => {
                const owned = gameState.upgrades[upgrade.id];
                const canAfford = gameState.ore >= upgrade.cost;
                
                const card = document.createElement('div');
                card.className = `upgrade-card ${owned ? 'owned' : ''} ${!canAfford && !owned ? 'locked' : ''}`;
                card.innerHTML = `
                    <div class="upgrade-icon">${upgrade.icon}</div>
                    <div class="upgrade-name">${upgrade.name}</div>
                    <div class="upgrade-desc">${upgrade.desc}</div>
                    <div class="upgrade-cost">${owned ? '‚úì OWNED' : formatNumber(upgrade.cost) + ' üíé'}</div>
                `;
                
                if (!owned) {
                    card.addEventListener('click', () => buyUpgrade(upgrade));
                }
                
                grid.appendChild(card);
            });
        }

        function buyUpgrade(upgrade) {
            if (gameState.ore >= upgrade.cost && !gameState.upgrades[upgrade.id]) {
                gameState.ore -= upgrade.cost;
                gameState.upgrades[upgrade.id] = true;
                upgrade.effect();
                updateDisplays();
                generateUpgrades();
                saveGame();
                showToast(`‚ú® Purchased: ${upgrade.name}!`);
            } else if (gameState.ore < upgrade.cost) {
                showToast('‚ùå Not enough ore!');
            }
        }

        // AI Chat with real API
        const chatSend = document.getElementById('chatSend');
        const chatInput = document.getElementById('chatInput');
        
        chatSend.addEventListener('click', sendMessage);
        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage();
        });

        async function sendMessage() {
            const message = chatInput.value.trim();
            if (!message) return;
            
            const cost = gameState.unlimitedAI ? 0 : getMessageCost(gameState.messageCount);
            
            if (gameState.ore < cost && !gameState.unlimitedAI) {
                showToast(`‚ùå Need ${cost} ore!`);
                return;
            }
            
            // Deduct cost
            if (!gameState.unlimitedAI) {
                gameState.ore -= cost;
                gameState.messageCount++;
            }
            
            updateDisplays();
            saveGame();
            
            const messagesDiv = document.getElementById('chatMessages');
            
            // Add user message
            const userMsg = document.createElement('div');
            userMsg.className = 'chat-message user';
            userMsg.textContent = message;
            messagesDiv.appendChild(userMsg);
            
            chatInput.value = '';
            chatSend.disabled = true;
            
            // Typing indicator
            const typingMsg = document.createElement('div');
            typingMsg.className = 'chat-message ai';
            typingMsg.textContent = 'ü§î Thinking...';
            messagesDiv.appendChild(typingMsg);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            
            try {
                // Format model name for API
                let modelToUse = gameState.selectedModel;
                if (!modelToUse.startsWith('openrouter:')) {
                    modelToUse = `openrouter:${modelToUse}`;
                }
                
                const response = await fetch(`${API_BASE_URL}/chat`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        user_id: gameState.userId,
                        message: message,
                        model: modelToUse
                    })
                });
                
                if (!response.ok) {
                    throw new Error('API request failed');
                }
                
                const data = await response.json();
                typingMsg.innerHTML = parseCodeBlocks(data.response || 'No response received');
                
            } catch (error) {
                console.error('API Error:', error);
                // Fallback to local responses
                const fallbackResponses = [
                    "Hmm, the API seems to be taking a break. Try again in a moment! Meanwhile, mine more ore! üíé",
                    "Connection hiccup! The AI is probably too busy admiring your mining skills. üåü",
                    "Error connecting to the AI. But hey, that means more time to click rocks! ‚õèÔ∏è",
                ];
                typingMsg.textContent = fallbackResponses[Math.floor(Math.random() * fallbackResponses.length)];
            }
            
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            chatSend.disabled = false;
        }

        // Parse code blocks with <codestart> and <codeend>
        function parseCodeBlocks(text) {
            const codeBlockRegex = /<codestart>([\s\S]*?)<codeend>/g;
            let result = text;
            let blockId = 0;
            
            result = result.replace(codeBlockRegex, (match, code) => {
                blockId++;
                return `<div class="code-block-wrapper" data-code-id="${blockId}"><pre class="code-block">${escapeHtml(code.trim())}</pre></div>`;
            });
            
            // Also handle markdown-style code blocks
            const markdownRegex = /```(\w+)?\n?([\s\S]*?)```/g;
            result = result.replace(markdownRegex, (match, lang, code) => {
                blockId++;
                return `<div class="code-block-wrapper" data-code-id="${blockId}"><pre class="code-block">${escapeHtml(code.trim())}</pre></div>`;
            });
            
            return result;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Floating copy button for code blocks
        const floatingCopyBtn = document.getElementById('floatingCopyBtn');
        let currentCodeBlock = null;

        document.addEventListener('mousemove', (e) => {
            const codeWrapper = e.target.closest('.code-block-wrapper');
            
            if (codeWrapper) {
                currentCodeBlock = codeWrapper.querySelector('.code-block');
                floatingCopyBtn.style.display = 'block';
                floatingCopyBtn.style.left = (e.clientX + 15) + 'px';
                floatingCopyBtn.style.top = (e.clientY - 15) + 'px';
            } else {
                floatingCopyBtn.style.display = 'none';
                currentCodeBlock = null;
            }
        });

        floatingCopyBtn.addEventListener('click', () => {
            if (currentCodeBlock) {
                const text = currentCodeBlock.textContent;
                navigator.clipboard.writeText(text).then(() => {
                    floatingCopyBtn.textContent = '‚úÖ Copied!';
                    setTimeout(() => {
                        floatingCopyBtn.textContent = 'üìã Copy';
                    }, 1500);
                });
            }
        });

        // Minigames
        document.querySelectorAll('.minigame-card').forEach(card => {
            card.addEventListener('click', () => startMinigame(card.dataset.game));
        });

        document.getElementById('gameClose').addEventListener('click', closeMinigame);

        let currentGameCleanup = null;

        function startMinigame(gameType) {
            const modal = document.getElementById('gameModal');
            const container = document.getElementById('gameContainer');
            const title = document.getElementById('gameTitle');
            const area = document.getElementById('gameArea');
            
            // Reset container size
            container.classList.remove('fullscreen');
            
            modal.classList.add('active');
            
            // Cleanup previous game
            if (currentGameCleanup) {
                currentGameCleanup();
                currentGameCleanup = null;
            }
            
            switch(gameType) {
                case 'reaction': reactionGame(title, area); break;
                case 'memory': memoryGame(title, area); break;
                case 'dodge': dodgeGame(title, area); break;
                case 'speedclick': speedClickGame(title, area); break;
                case 'rhythm': rhythmGame(title, area); break;
                case 'math': mathGame(title, area); break;
                case 'slider': sliderGame(title, area); break;
                case 'wheel': wheelGame(title, area); break;
                case 'boss': bossGame(title, area); break;
                case 'subway': subwayGame(title, area, container); break;
                case 'fnf': fnfGame(title, area); break;
                case 'snake': snakeGame(title, area); break;
                case 'flappy': flappyGame(title, area); break;
                case 'pong': pongGame(title, area); break;
                case 'breakout': breakoutGame(title, area); break;
                case 'typing': typingGame(title, area); break;
                case 'colorMatch': colorMatchGame(title, area); break;
                case 'aim': aimGame(title, area); break;
                case '2048': game2048(title, area); break;
            }
        }

        function closeMinigame() {
            document.getElementById('gameModal').classList.remove('active');
            document.getElementById('gameArea').innerHTML = '';
            if (currentGameCleanup) {
                currentGameCleanup();
                currentGameCleanup = null;
            }
        }

        // ==================== MINIGAMES ====================

        // Reaction Game
        function reactionGame(title, area) {
            title.textContent = '‚ö° Reaction Test';
            area.innerHTML = `
                <p>Click when the box turns GREEN!</p>
                <div class="reaction-box waiting" id="reactionBox">Wait...</div>
                <p class="game-score" id="reactionResult"></p>
            `;
            
            const box = document.getElementById('reactionBox');
            let startTime, canClick = false, timeout;
            
            const delay = 1000 + Math.random() * 4000;
            
            timeout = setTimeout(() => {
                box.classList.remove('waiting');
                box.classList.add('ready');
                box.textContent = 'CLICK!';
                startTime = Date.now();
                canClick = true;
            }, delay);
            
            function handler() {
                if (!canClick) {
                    document.getElementById('reactionResult').textContent = 'Too early! üòÖ';
                    box.removeEventListener('click', handler);
                    return;
                }
                
                const reactionTime = Date.now() - startTime;
                let reward = Math.max(50, 200 - reactionTime);
                
                document.getElementById('reactionResult').textContent = 
                    `${reactionTime}ms - ${reward} ore earned!`;
                
                gameState.ore += reward;
                gameState.totalMined += reward;
                updateDisplays();
                saveGame();
                
                box.removeEventListener('click', handler);
            }
            
            box.addEventListener('click', handler);
            
            currentGameCleanup = () => {
                clearTimeout(timeout);
                box.removeEventListener('click', handler);
            };
        }

        // Memory Game
        function memoryGame(title, area) {
            title.textContent = 'üß† Memory Match';
            
            const emojis = ['üéÆ', 'üíé', '‚≠ê', 'üî•', 'üí´', 'üåü', '‚ú®', 'üéØ'];
            const cards = [...emojis, ...emojis].sort(() => Math.random() - 0.5);
            
            area.innerHTML = `
                <p>Match all pairs!</p>
                <div class="memory-grid" id="memoryGrid"></div>
                <p class="game-score" id="memoryScore">Pairs: 0/8</p>
            `;
            
            const grid = document.getElementById('memoryGrid');
            let flipped = [];
            let matched = 0;
            let canFlip = true;
            
            cards.forEach((emoji, i) => {
                const tile = document.createElement('div');
                tile.className = 'memory-tile';
                tile.dataset.index = i;
                tile.dataset.emoji = emoji;
                
                tile.addEventListener('click', () => {
                    if (!canFlip || tile.classList.contains('revealed') || tile.classList.contains('matched')) return;
                    
                    tile.classList.add('revealed');
                    tile.textContent = emoji;
                    flipped.push(tile);
                    
                    if (flipped.length === 2) {
                        canFlip = false;
                        
                        if (flipped[0].dataset.emoji === flipped[1].dataset.emoji) {
                            flipped.forEach(t => t.classList.add('matched'));
                            matched++;
                            document.getElementById('memoryScore').textContent = `Pairs: ${matched}/8`;
                            flipped = [];
                            canFlip = true;
                            
                            if (matched === 8) {
                                const reward = 500;
                                gameState.ore += reward;
                                gameState.totalMined += reward;
                                updateDisplays();
                                saveGame();
                                showToast(`üéâ Memory Master! +${reward} ore!`);
                            }
                        } else {
                            setTimeout(() => {
                                flipped.forEach(t => {
                                    t.classList.remove('revealed');
                                    t.textContent = '';
                                });
                                flipped = [];
                                canFlip = true;
                            }, 1000);
                        }
                    }
                });
                
                grid.appendChild(tile);
            });
        }

        // Dodge Game
        function dodgeGame(title, area) {
            title.textContent = 'üöó Dodge Blocks';
            area.innerHTML = `
                <p>Move your mouse to dodge!</p>
                <div class="dodge-area" id="dodgeArea">
                    <div class="dodge-player" id="dodgePlayer"></div>
                </div>
                <p class="game-timer" id="dodgeTimer">0.0s</p>
            `;
            
            const dodgeArea = document.getElementById('dodgeArea');
            const player = document.getElementById('dodgePlayer');
            const timerEl = document.getElementById('dodgeTimer');
            
            let startTime = Date.now();
            let gameRunning = true;
            let blocks = [];
            let animFrame;
            let spawnInterval;
            
            function handleMove(e) {
                if (!gameRunning) return;
                const rect = dodgeArea.getBoundingClientRect();
                const x = Math.max(0, Math.min(270, e.clientX - rect.left - 15));
                const y = Math.max(0, Math.min(270, e.clientY - rect.top - 15));
                player.style.left = x + 'px';
                player.style.top = y + 'px';
            }
            
            dodgeArea.addEventListener('mousemove', handleMove);
            
            function spawnBlock() {
                if (!gameRunning) return;
                
                const block = document.createElement('div');
                block.className = 'dodge-block';
                block.style.left = Math.random() * 260 + 'px';
                block.style.top = '-40px';
                dodgeArea.appendChild(block);
                blocks.push(block);
            }
            
            function update() {
                if (!gameRunning) return;
                
                const elapsed = (Date.now() - startTime) / 1000;
                timerEl.textContent = elapsed.toFixed(1) + 's';
                
                const playerRect = player.getBoundingClientRect();
                
                blocks.forEach(block => {
                    const top = parseFloat(block.style.top) + 3;
                    block.style.top = top + 'px';
                    
                    const blockRect = block.getBoundingClientRect();
                    
                    if (top > 300) {
                        block.remove();
                        blocks = blocks.filter(b => b !== block);
                    }
                    
                    if (playerRect.left < blockRect.right &&
                        playerRect.right > blockRect.left &&
                        playerRect.top < blockRect.bottom &&
                        playerRect.bottom > blockRect.top) {
                        gameRunning = false;
                        const reward = Math.floor(elapsed * 10);
                        gameState.ore += reward;
                        gameState.totalMined += reward;
                        updateDisplays();
                        saveGame();
                        timerEl.textContent = `Game Over! +${reward} ore!`;
                    }
                });
                
                if (gameRunning) animFrame = requestAnimationFrame(update);
            }
            
            spawnInterval = setInterval(() => {
                if (gameRunning) spawnBlock();
            }, 500);
            
            update();
            
            currentGameCleanup = () => {
                gameRunning = false;
                clearInterval(spawnInterval);
                cancelAnimationFrame(animFrame);
                dodgeArea.removeEventListener('mousemove', handleMove);
            };
        }

        // Speed Click Game
        function speedClickGame(title, area) {
            title.textContent = 'üëÜ Speed Click';
            area.innerHTML = `
                <p>Click as fast as you can in 10 seconds!</p>
                <div class="click-target" id="clickTarget" style="width:150px;height:150px;background:radial-gradient(circle,var(--neon-pink),var(--neon-blue));border-radius:50%;cursor:pointer;"></div>
                <p class="game-score" id="clickCount">Clicks: 0</p>
                <p class="game-timer" id="clickTimer">10.0s</p>
            `;
            
            const target = document.getElementById('clickTarget');
            let clicks = 0;
            let timeLeft = 10;
            let gameRunning = true;
            
            function handleClick(e) {
                if (!gameRunning) return;
                clicks++;
                document.getElementById('clickCount').textContent = `Clicks: ${clicks}`;
                createMultipleParticles(e.clientX, e.clientY, 2);
            }
            
            target.addEventListener('click', handleClick);
            
            const timer = setInterval(() => {
                timeLeft -= 0.1;
                document.getElementById('clickTimer').textContent = timeLeft.toFixed(1) + 's';
                
                if (timeLeft <= 0) {
                    clearInterval(timer);
                    gameRunning = false;
                    const reward = clicks * 5;
                    gameState.ore += reward;
                    gameState.totalMined += reward;
                    updateDisplays();
                    saveGame();
                    document.getElementById('clickTimer').textContent = `Done! +${reward} ore!`;
                }
            }, 100);
            
            currentGameCleanup = () => {
                gameRunning = false;
                clearInterval(timer);
                target.removeEventListener('click', handleClick);
            };
        }

        // Rhythm Game
        function rhythmGame(title, area) {
            title.textContent = 'üéµ Rhythm Tap';
            area.innerHTML = `
                <p>Press SPACE when notes hit the target!</p>
                <div class="rhythm-lane" id="rhythmLane" style="width:80px;height:300px;background:var(--bg-tertiary);border-radius:10px;position:relative;overflow:hidden;">
                    <div style="position:absolute;bottom:20px;left:10px;right:10px;height:20px;background:rgba(0,245,255,0.3);border-radius:5px;border:2px solid var(--neon-blue);"></div>
                </div>
                <p class="game-score" id="rhythmScore">Score: 0</p>
                <p class="game-timer" id="rhythmHits">Perfect: 0 | Good: 0 | Miss: 0</p>
            `;
            
            const lane = document.getElementById('rhythmLane');
            let score = 0;
            let perfect = 0, good = 0, miss = 0;
            let notes = [];
            let gameRunning = true;
            let notesSpawned = 0;
            const maxNotes = 15;
            let animFrame;
            let spawnInterval;
            
            function spawnNote() {
                if (!gameRunning || notesSpawned >= maxNotes) return;
                
                const note = document.createElement('div');
                note.style.cssText = 'position:absolute;left:10px;right:10px;height:20px;background:var(--neon-pink);border-radius:5px;top:-20px;';
                lane.appendChild(note);
                notes.push({ el: note, hit: false });
                notesSpawned++;
            }
            
            function update() {
                if (!gameRunning) return;
                
                notes.forEach((note) => {
                    const top = parseFloat(note.el.style.top) + 2;
                    note.el.style.top = top + 'px';
                    
                    if (top > 300 && !note.hit) {
                        miss++;
                        note.hit = true;
                        note.el.remove();
                        updateRhythmDisplay();
                    }
                });
                
                notes = notes.filter(n => !n.hit || parseFloat(n.el.style.top) <= 300);
                
                if (notes.length === 0 && notesSpawned >= maxNotes) {
                    gameRunning = false;
                    const reward = score;
                    gameState.ore += reward;
                    gameState.totalMined += reward;
                    updateDisplays();
                    saveGame();
                    document.getElementById('rhythmScore').textContent = `Done! +${reward} ore!`;
                } else {
                    animFrame = requestAnimationFrame(update);
                }
            }
            
            function updateRhythmDisplay() {
                document.getElementById('rhythmScore').textContent = `Score: ${score}`;
                document.getElementById('rhythmHits').textContent = `Perfect: ${perfect} | Good: ${good} | Miss: ${miss}`;
            }
            
            function handleKeydown(e) {
                if (e.code !== 'Space' || !gameRunning) return;
                e.preventDefault();
                
                const targetTop = 260;
                let closestNote = null;
                let closestDist = Infinity;
                
                notes.forEach(note => {
                    if (note.hit) return;
                    const top = parseFloat(note.el.style.top);
                    const dist = Math.abs(top - targetTop);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closestNote = note;
                    }
                });
                
                if (closestNote && closestDist < 50) {
                    closestNote.hit = true;
                    closestNote.el.remove();
                    
                    if (closestDist < 15) {
                        perfect++;
                        score += 20;
                    } else {
                        good++;
                        score += 10;
                    }
                    updateRhythmDisplay();
                }
            }
            
            document.addEventListener('keydown', handleKeydown);
            
            spawnInterval = setInterval(() => {
                if (gameRunning && notesSpawned < maxNotes) spawnNote();
                else clearInterval(spawnInterval);
            }, 600);
            
            update();
            
            currentGameCleanup = () => {
                gameRunning = false;
                clearInterval(spawnInterval);
                cancelAnimationFrame(animFrame);
                document.removeEventListener('keydown', handleKeydown);
            };
        }

        // Math Game
        function mathGame(title, area) {
            title.textContent = 'üî¢ Math Rush';
            area.innerHTML = `
                <p>Solve as many as you can in 30 seconds!</p>
                <div class="math-problem" id="mathProblem"></div>
                <input type="number" class="math-input" id="mathInput" autofocus>
                <p class="game-score" id="mathScore">Correct: 0</p>
                <p class="game-timer" id="mathTimer">30.0s</p>
            `;
            
            const problemEl = document.getElementById('mathProblem');
            const input = document.getElementById('mathInput');
            let correct = 0;
            let answer = 0;
            let timeLeft = 30;
            let gameRunning = true;
            
            function newProblem() {
                const a = Math.floor(Math.random() * 20) + 1;
                const b = Math.floor(Math.random() * 20) + 1;
                const ops = ['+', '-', '√ó'];
                const op = ops[Math.floor(Math.random() * ops.length)];
                
                switch(op) {
                    case '+': answer = a + b; break;
                    case '-': answer = a - b; break;
                    case '√ó': answer = a * b; break;
                }
                
                problemEl.textContent = `${a} ${op} ${b} = ?`;
                input.value = '';
                input.focus();
            }
            
            function handleKeypress(e) {
                if (e.key === 'Enter' && gameRunning) {
                    if (parseInt(input.value) === answer) {
                        correct++;
                        document.getElementById('mathScore').textContent = `Correct: ${correct}`;
                        newProblem();
                    } else {
                        input.style.borderColor = 'red';
                        setTimeout(() => input.style.borderColor = '', 200);
                    }
                }
            }
            
            input.addEventListener('keypress', handleKeypress);
            
            const timer = setInterval(() => {
                timeLeft -= 0.1;
                document.getElementById('mathTimer').textContent = timeLeft.toFixed(1) + 's';
                
                if (timeLeft <= 0) {
                    clearInterval(timer);
                    gameRunning = false;
                    const reward = correct * 100;
                    gameState.ore += reward;
                    gameState.totalMined += reward;
                    updateDisplays();
                    saveGame();
                    document.getElementById('mathTimer').textContent = `Done! +${reward} ore!`;
                    input.disabled = true;
                }
            }, 100);
            
            newProblem();
            
            currentGameCleanup = () => {
                gameRunning = false;
                clearInterval(timer);
                input.removeEventListener('keypress', handleKeypress);
            };
        }

        // Slider Game
        function sliderGame(title, area) {
            title.textContent = 'üéØ Precision Stop';
            area.innerHTML = `
                <p>Stop the marker in the GREEN zone for diamonds!</p>
                <div class="precision-slider" id="precisionSlider">
                    <div class="slider-marker" id="sliderMarker"></div>
                </div>
                <button class="game-btn" id="stopBtn">STOP!</button>
                <p class="game-score" id="sliderResult"></p>
            `;
            
            const marker = document.getElementById('sliderMarker');
            let position = 0;
            let direction = 1;
            let speed = 3;
            let gameRunning = true;
            let animFrame;
            
            function animate() {
                if (!gameRunning) return;
                
                position += direction * speed;
                if (position >= 290) direction = -1;
                if (position <= 0) direction = 1;
                
                marker.style.left = position + 'px';
                animFrame = requestAnimationFrame(animate);
            }
            
            function handleStop() {
                if (!gameRunning) return;
                gameRunning = false;
                
                const greenStart = 135;
                const greenEnd = 165;
                
                if (position >= greenStart && position <= greenEnd) {
                    gameState.diamondOre += 1;
                    document.getElementById('sliderResult').textContent = 'üí† DIAMOND! Perfect!';
                    showToast('üí† +1 Diamond Ore!');
                } else {
                    const reward = 50;
                    gameState.ore += reward;
                    gameState.totalMined += reward;
                    document.getElementById('sliderResult').textContent = `Close! +${reward} ore`;
                }
                
                updateDisplays();
                saveGame();
            }
            
            document.getElementById('stopBtn').addEventListener('click', handleStop);
            
            animate();
            
            currentGameCleanup = () => {
                gameRunning = false;
                cancelAnimationFrame(animFrame);
            };
        }

        // Wheel Game
        function wheelGame(title, area) {
            title.textContent = 'üé∞ Lucky Wheel';
            area.innerHTML = `
                <p>Spin for prizes!</p>
                <div class="wheel-container">
                    <div class="wheel-pointer">‚¨áÔ∏è</div>
                    <div class="wheel" id="wheel"></div>
                </div>
                <button class="game-btn" id="spinBtn">SPIN!</button>
                <p class="game-score" id="wheelResult"></p>
            `;
            
            const wheel = document.getElementById('wheel');
            const spinBtn = document.getElementById('spinBtn');
            let spinning = false;
            
            const prizes = [
                { text: '100 Ore', ore: 100, diamond: 0 },
                { text: '1 Diamond', ore: 0, diamond: 1 },
                { text: '200 Ore', ore: 200, diamond: 0 },
                { text: '2 Diamonds', ore: 0, diamond: 2 },
                { text: '500 Ore', ore: 500, diamond: 0 },
                { text: '3 Diamonds', ore: 0, diamond: 3 },
                { text: '1000 Ore', ore: 1000, diamond: 0 },
                { text: '5 Diamonds!', ore: 0, diamond: 5 },
            ];
            
            function handleSpin() {
                if (spinning) return;
                spinning = true;
                spinBtn.disabled = true;
                
                const spins = 5 + Math.random() * 5;
                const extraDegrees = Math.random() * 360;
                const totalRotation = spins * 360 + extraDegrees;
                
                wheel.style.transform = `rotate(${totalRotation}deg)`;
                
                setTimeout(() => {
                    const finalAngle = extraDegrees;
                    const prizeIndex = Math.floor((360 - (finalAngle % 360)) / 45) % 8;
                    const prize = prizes[prizeIndex];
                    
                    gameState.ore += prize.ore;
                    gameState.totalMined += prize.ore;
                    gameState.diamondOre += prize.diamond;
                    
                    document.getElementById('wheelResult').textContent = `üéâ ${prize.text}!`;
                    
                    if (prize.diamond > 0) {
                        showToast(`üí† +${prize.diamond} Diamond Ore!`);
                    }
                    
                    updateDisplays();
                    saveGame();
                    spinning = false;
                    spinBtn.disabled = false;
                }, 4000);
            }
            
            spinBtn.addEventListener('click', handleSpin);
        }

        // Boss Game
        function bossGame(title, area) {
            title.textContent = 'üëπ Mini Boss';
            area.innerHTML = `
                <p>Defeat the Air Elemental!</p>
                <div class="boss-container">
                    <div class="boss-health">
                        <div class="boss-health-fill" id="bossHealth" style="width: 100%"></div>
                    </div>
                    <div class="boss-enemy" id="bossEnemy" style="font-size:8rem;cursor:pointer;user-select:none;">üëπ</div>
                </div>
                <p class="game-score" id="bossScore">HP: 100/100</p>
            `;
            
            const boss = document.getElementById('bossEnemy');
            const healthBar = document.getElementById('bossHealth');
            let hp = 100;
            let gameRunning = true;
            
            function handleClick(e) {
                if (!gameRunning) return;
                
                const damage = 5 + Math.floor(Math.random() * 5);
                hp -= damage;
                
                if (hp < 0) hp = 0;
                
                healthBar.style.width = hp + '%';
                document.getElementById('bossScore').textContent = `HP: ${hp}/100`;
                
                createMultipleParticles(e.clientX, e.clientY, 3);
                boss.style.transform = 'scale(0.9)';
                setTimeout(() => boss.style.transform = '', 100);
                
                if (hp <= 0) {
                    gameRunning = false;
                    boss.textContent = 'üíÄ';
                    
                    const oreReward = 500;
                    const diamondReward = 1;
                    
                    gameState.ore += oreReward;
                    gameState.totalMined += oreReward;
                    gameState.diamondOre += diamondReward;
                    
                    updateDisplays();
                    saveGame();
                    
                    document.getElementById('bossScore').textContent = `Victory! +${oreReward} ore +${diamondReward} üí†!`;
                    showToast('üëπ Boss Defeated! +1 Diamond!');
                }
            }
            
            boss.addEventListener('click', handleClick);
            
            currentGameCleanup = () => {
                gameRunning = false;
                boss.removeEventListener('click', handleClick);
            };
        }

        // Subway Surfers Clone
        function subwayGame(title, area, container) {
            title.textContent = 'üèÉ Air Surfers';
            area.innerHTML = `
                <p>Use LEFT/RIGHT arrows to move, UP to jump!</p>
                <div class="subway-game" id="subwayGame">
                    <div class="subway-player" id="subwayPlayer" style="left:130px;"></div>
                    <div class="subway-lanes"></div>
                </div>
                <p class="game-score" id="subwayScore">Distance: 0m | Coins: 0</p>
            `;
            
            const game = document.getElementById('subwayGame');
            const player = document.getElementById('subwayPlayer');
            let lane = 1; // 0, 1, 2
            let distance = 0;
            let coins = 0;
            let gameRunning = true;
            let obstacles = [];
            let coinElements = [];
            let animFrame;
            let isJumping = false;
            
            const lanePositions = [30, 130, 230];
            
            function handleKeydown(e) {
                if (!gameRunning) return;
                
                if (e.key === 'ArrowLeft' && lane > 0) {
                    lane--;
                    player.style.left = lanePositions[lane] + 'px';
                }
                if (e.key === 'ArrowRight' && lane < 2) {
                    lane++;
                    player.style.left = lanePositions[lane] + 'px';
                }
                if (e.key === 'ArrowUp' && !isJumping) {
                    isJumping = true;
                    player.style.bottom = '150px';
                    setTimeout(() => {
                        player.style.bottom = '50px';
                        isJumping = false;
                    }, 500);
                }
            }
            
            document.addEventListener('keydown', handleKeydown);
            
            function spawnObstacle() {
                const obs = document.createElement('div');
                obs.style.cssText = `position:absolute;width:60px;height:40px;background:var(--neon-pink);border-radius:5px;top:-40px;left:${lanePositions[Math.floor(Math.random() * 3)]}px;`;
                game.appendChild(obs);
                obstacles.push(obs);
            }
            
            function spawnCoin() {
                const coin = document.createElement('div');
                coin.style.cssText = `position:absolute;width:20px;height:20px;background:gold;border-radius:50%;top:-20px;left:${lanePositions[Math.floor(Math.random() * 3)] + 10}px;`;
                game.appendChild(coin);
                coinElements.push(coin);
            }
            
            let spawnTimer = 0;
            
            function update() {
                if (!gameRunning) return;
                
                distance += 0.5;
                spawnTimer++;
                
                if (spawnTimer % 60 === 0) spawnObstacle();
                if (spawnTimer % 30 === 0) spawnCoin();
                
                const playerRect = player.getBoundingClientRect();
                
                obstacles.forEach((obs, i) => {
                    const top = parseFloat(obs.style.top) + 5;
                    obs.style.top = top + 'px';
                    
                    if (top > 400) {
                        obs.remove();
                        obstacles.splice(i, 1);
                    }
                    
                    const obsRect = obs.getBoundingClientRect();
                    if (!isJumping &&
                        playerRect.left < obsRect.right &&
                        playerRect.right > obsRect.left &&
                        playerRect.top < obsRect.bottom &&
                        playerRect.bottom > obsRect.top) {
                        gameRunning = false;
                        const reward = Math.floor(distance / 100) * 50 + coins * 10;
                        gameState.ore += reward;
                        gameState.totalMined += reward;
                        updateDisplays();
                        saveGame();
                        document.getElementById('subwayScore').textContent = `Game Over! +${reward} ore!`;
                    }
                });
                
                coinElements.forEach((coin, i) => {
                    const top = parseFloat(coin.style.top) + 5;
                    coin.style.top = top + 'px';
                    
                    if (top > 400) {
                        coin.remove();
                        coinElements.splice(i, 1);
                    }
                    
                    const coinRect = coin.getBoundingClientRect();
                    if (playerRect.left < coinRect.right &&
                        playerRect.right > coinRect.left &&
                        playerRect.top < coinRect.bottom &&
                        playerRect.bottom > coinRect.top) {
                        coins++;
                        coin.remove();
                        coinElements.splice(i, 1);
                    }
                });
                
                document.getElementById('subwayScore').textContent = `Distance: ${Math.floor(distance)}m | Coins: ${coins}`;
                
                if (gameRunning) animFrame = requestAnimationFrame(update);
            }
            
            update();
            
            currentGameCleanup = () => {
                gameRunning = false;
                cancelAnimationFrame(animFrame);
                document.removeEventListener('keydown', handleKeydown);
            };
        }

        // Friday Night Funkin' Clone
        function fnfGame(title, area) {
            title.textContent = 'üé§ Friday Night Minin\'';
            area.innerHTML = `
                <p>Press D F J K when notes hit the targets!</p>
                <div class="fnf-game" id="fnfGame">
                    <div class="fnf-lanes">
                        <div class="fnf-lane" data-key="d"><div class="fnf-target"></div></div>
                        <div class="fnf-lane" data-key="f"><div class="fnf-target"></div></div>
                        <div class="fnf-lane" data-key="j"><div class="fnf-target"></div></div>
                        <div class="fnf-lane" data-key="k"><div class="fnf-target"></div></div>
                    </div>
                </div>
                <div class="fnf-keys">
                    <div class="fnf-key" id="key-d">D</div>
                    <div class="fnf-key" id="key-f">F</div>
                    <div class="fnf-key" id="key-j">J</div>
                    <div class="fnf-key" id="key-k">K</div>
                </div>
                <p class="game-score" id="fnfScore">Score: 0 | Combo: 0</p>
            `;
            
            const game = document.getElementById('fnfGame');
            const lanes = game.querySelectorAll('.fnf-lane');
            let score = 0;
            let combo = 0;
            let gameRunning = true;
            let notes = [];
            let notesSpawned = 0;
            const maxNotes = 40;
            const colors = ['left', 'down', 'up', 'right'];
            let animFrame;
            
            function spawnNote() {
                if (!gameRunning || notesSpawned >= maxNotes) return;
                
                const laneIndex = Math.floor(Math.random() * 4);
                const lane = lanes[laneIndex];
                const note = document.createElement('div');
                note.className = `fnf-note ${colors[laneIndex]}`;
                note.style.top = '-30px';
                note.dataset.lane = laneIndex;
                lane.appendChild(note);
                notes.push({ el: note, lane: laneIndex, hit: false });
                notesSpawned++;
            }
            
            function handleKeydown(e) {
                if (!gameRunning) return;
                
                const keyMap = { 'd': 0, 'f': 1, 'j': 2, 'k': 3 };
                const laneIndex = keyMap[e.key.toLowerCase()];
                
                if (laneIndex === undefined) return;
                
                const keyEl = document.getElementById(`key-${e.key.toLowerCase()}`);
                if (keyEl) keyEl.classList.add('active');
                
                const targetTop = 330;
                let hitNote = null;
                let closestDist = 50;
                
                notes.forEach(note => {
                    if (note.hit || note.lane !== laneIndex) return;
                    const top = parseFloat(note.el.style.top);
                    const dist = Math.abs(top - targetTop);
                    if (dist < closestDist) {
                        closestDist = dist;
                        hitNote = note;
                    }
                });
                
                if (hitNote) {
                    hitNote.hit = true;
                    hitNote.el.remove();
                    combo++;
                    score += 25 * (1 + Math.floor(combo / 10) * 0.1);
                    document.getElementById('fnfScore').textContent = `Score: ${Math.floor(score)} | Combo: ${combo}`;
                }
            }
            
            function handleKeyup(e) {
                const keyEl = document.getElementById(`key-${e.key.toLowerCase()}`);
                if (keyEl) keyEl.classList.remove('active');
            }
            
            document.addEventListener('keydown', handleKeydown);
            document.addEventListener('keyup', handleKeyup);
            
            function update() {
                if (!gameRunning) return;
                
                notes.forEach((note, i) => {
                    if (note.hit) return;
                    const top = parseFloat(note.el.style.top) + 3;
                    note.el.style.top = top + 'px';
                    
                    if (top > 380) {
                        note.hit = true;
                        note.el.remove();
                        combo = 0;
                        document.getElementById('fnfScore').textContent = `Score: ${Math.floor(score)} | Combo: ${combo}`;
                    }
                });
                
                notes = notes.filter(n => !n.hit);
                
                if (notes.length === 0 && notesSpawned >= maxNotes) {
                    gameRunning = false;
                    const reward = Math.floor(score);
                    gameState.ore += reward;
                    gameState.totalMined += reward;
                    updateDisplays();
                    saveGame();
                    document.getElementById('fnfScore').textContent = `Song Complete! +${reward} ore!`;
                } else {
                    animFrame = requestAnimationFrame(update);
                }
            }
            
            const spawnInterval = setInterval(() => {
                if (gameRunning && notesSpawned < maxNotes) spawnNote();
                else clearInterval(spawnInterval);
            }, 400);
            
            update();
            
            currentGameCleanup = () => {
                gameRunning = false;
                cancelAnimationFrame(animFrame);
                clearInterval(spawnInterval);
                document.removeEventListener('keydown', handleKeydown);
                document.removeEventListener('keyup', handleKeyup);
            };
        }

        // Snake Game
        function snakeGame(title, area) {
            title.textContent = 'üêç Air Snake';
            area.innerHTML = `
                <p>Use arrow keys to move!</p>
                <div class="snake-game" id="snakeGame"></div>
                <p class="game-score" id="snakeScore">Length: 3</p>
            `;
            
            const game = document.getElementById('snakeGame');
            let snake = [{x: 150, y: 150}, {x: 135, y: 150}, {x: 120, y: 150}];
            let direction = {x: 15, y: 0};
            let food = {x: 225, y: 150};
            let gameRunning = true;
            let gameInterval;
            
            function draw() {
                game.innerHTML = '';
                
                // Draw food
                const foodEl = document.createElement('div');
                foodEl.className = 'snake-food';
                foodEl.style.left = food.x + 'px';
                foodEl.style.top = food.y + 'px';
                game.appendChild(foodEl);
                
                // Draw snake
                snake.forEach((seg, i) => {
                    const segEl = document.createElement('div');
                    segEl.className = 'snake-segment';
                    segEl.style.left = seg.x + 'px';
                    segEl.style.top = seg.y + 'px';
                    if (i === 0) segEl.style.background = 'var(--neon-blue)';
                    game.appendChild(segEl);
                });
            }
            
            function update() {
                if (!gameRunning) return;
                
                const newHead = {
                    x: snake[0].x + direction.x,
                    y: snake[0].y + direction.y
                };
                
                // Wall collision
                if (newHead.x < 0 || newHead.x >= 300 || newHead.y < 0 || newHead.y >= 300) {
                    endGame();
                    return;
                }
                
                // Self collision
                if (snake.some(seg => seg.x === newHead.x && seg.y === newHead.y)) {
                    endGame();
                    return;
                }
                
                snake.unshift(newHead);
                
                // Food collision
                if (newHead.x === food.x && newHead.y === food.y) {
                    food = {
                        x: Math.floor(Math.random() * 20) * 15,
                        y: Math.floor(Math.random() * 20) * 15
                    };
                    document.getElementById('snakeScore').textContent = `Length: ${snake.length}`;
                } else {
                    snake.pop();
                }
                
                draw();
            }
            
            function endGame() {
                gameRunning = false;
                clearInterval(gameInterval);
                const reward = (snake.length - 3) * 10;
                gameState.ore += reward;
                gameState.totalMined += reward;
                updateDisplays();
                saveGame();
                document.getElementById('snakeScore').textContent = `Game Over! +${reward} ore!`;
            }
            
            function handleKeydown(e) {
                if (!gameRunning) return;
                
                const newDir = {x: direction.x, y: direction.y};
                
                if (e.key === 'ArrowUp' && direction.y === 0) { newDir.x = 0; newDir.y = -15; }
                if (e.key === 'ArrowDown' && direction.y === 0) { newDir.x = 0; newDir.y = 15; }
                if (e.key === 'ArrowLeft' && direction.x === 0) { newDir.x = -15; newDir.y = 0; }
                if (e.key === 'ArrowRight' && direction.x === 0) { newDir.x = 15; newDir.y = 0; }
                
                direction = newDir;
            }
            
            document.addEventListener('keydown', handleKeydown);
            
            draw();
            gameInterval = setInterval(update, 150);
            
            currentGameCleanup = () => {
                gameRunning = false;
                clearInterval(gameInterval);
                document.removeEventListener('keydown', handleKeydown);
            };
        }

        // Flappy Bird Clone
        function flappyGame(title, area) {
            title.textContent = 'üê¶ Flappy Ore';
            area.innerHTML = `
                <p>Click or press SPACE to flap!</p>
                <div class="flappy-game" id="flappyGame">
                    <div class="flappy-bird" id="flappyBird" style="top:200px;"></div>
                </div>
                <p class="game-score" id="flappyScore">Score: 0</p>
            `;
            
            const game = document.getElementById('flappyGame');
            const bird = document.getElementById('flappyBird');
            let birdY = 200;
            let velocity = 0;
            let score = 0;
            let gameRunning = true;
            let pipes = [];
            let animFrame;
            let spawnTimer = 0;
            
            const gravity = 0.5;
            const jumpForce = -8;
            
            function flap() {
                if (!gameRunning) return;
                velocity = jumpForce;
            }
            
            function handleKeydown(e) {
                if (e.code === 'Space') {
                    e.preventDefault();
                    flap();
                }
            }
            
            game.addEventListener('click', flap);
            document.addEventListener('keydown', handleKeydown);
            
            function spawnPipe() {
                const gapY = 100 + Math.random() * 200;
                const gapHeight = 100;
                
                const topPipe = document.createElement('div');
                topPipe.className = 'flappy-pipe';
                topPipe.style.cssText = `right:-50px;top:0;height:${gapY - gapHeight/2}px;`;
                game.appendChild(topPipe);
                
                const bottomPipe = document.createElement('div');
                bottomPipe.className = 'flappy-pipe';
                bottomPipe.style.cssText = `right:-50px;bottom:0;height:${400 - gapY - gapHeight/2}px;`;
                game.appendChild(bottomPipe);
                
                pipes.push({ top: topPipe, bottom: bottomPipe, scored: false });
            }
            
            function update() {
                if (!gameRunning) return;
                
                velocity += gravity;
                birdY += velocity;
                bird.style.top = birdY + 'px';
                
                // Bounds check
                if (birdY < 0 || birdY > 370) {
                    endGame();
                    return;
                }
                
                spawnTimer++;
                if (spawnTimer % 100 === 0) spawnPipe();
                
                const birdRect = bird.getBoundingClientRect();
                
                pipes.forEach((pipe, i) => {
                    const right = parseFloat(pipe.top.style.right) + 3;
                    pipe.top.style.right = right + 'px';
                    pipe.bottom.style.right = right + 'px';
                    
                    if (right > 300) {
                        pipe.top.remove();
                        pipe.bottom.remove();
                        pipes.splice(i, 1);
                    }
                    
                    // Collision
                    const topRect = pipe.top.getBoundingClientRect();
                    const bottomRect = pipe.bottom.getBoundingClientRect();
                    
                    if ((birdRect.left < topRect.right && birdRect.right > topRect.left &&
                         birdRect.top < topRect.bottom) ||
                        (birdRect.left < bottomRect.right && birdRect.right > bottomRect.left &&
                         birdRect.bottom > bottomRect.top)) {
                        endGame();
                        return;
                    }
                    
                    // Score
                    if (!pipe.scored && right > 250) {
                        pipe.scored = true;
                        score++;
                        document.getElementById('flappyScore').textContent = `Score: ${score}`;
                    }
                });
                
                if (gameRunning) animFrame = requestAnimationFrame(update);
            }
            
            function endGame() {
                gameRunning = false;
                const reward = score * 20;
                gameState.ore += reward;
                gameState.totalMined += reward;
                updateDisplays();
                saveGame();
                document.getElementById('flappyScore').textContent = `Game Over! +${reward} ore!`;
            }
            
            update();
            
            currentGameCleanup = () => {
                gameRunning = false;
                cancelAnimationFrame(animFrame);
                game.removeEventListener('click', flap);
                document.removeEventListener('keydown', handleKeydown);
            };
        }

        // Pong Game
        function pongGame(title, area) {
            title.textContent = 'üèì Air Pong';
            area.innerHTML = `
                <p>Move mouse to control paddle!</p>
                <div class="pong-game" id="pongGame">
                    <div class="pong-paddle" id="playerPaddle" style="left:20px;top:120px;"></div>
                    <div class="pong-paddle" id="aiPaddle" style="right:20px;top:120px;"></div>
                    <div class="pong-ball" id="pongBall" style="left:192px;top:142px;"></div>
                </div>
                <p class="game-score" id="pongScore">You: 0 | AI: 0</p>
            `;
            
            const game = document.getElementById('pongGame');
            const playerPaddle = document.getElementById('playerPaddle');
            const aiPaddle = document.getElementById('aiPaddle');
            const ball = document.getElementById('pongBall');
            
            let ballX = 192, ballY = 142;
            let ballVX = 3, ballVY = 2;
            let playerScore = 0, aiScore = 0;
            let gameRunning = true;
            let animFrame;
            
            function handleMove(e) {
                const rect = game.getBoundingClientRect();
                const y = Math.max(0, Math.min(240, e.clientY - rect.top - 30));
                playerPaddle.style.top = y + 'px';
            }
            
            game.addEventListener('mousemove', handleMove);
            
            function update() {
                if (!gameRunning) return;
                
                // Move ball
                ballX += ballVX;
                ballY += ballVY;
                
                // Wall bounce
                if (ballY <= 0 || ballY >= 285) ballVY = -ballVY;
                
                // AI paddle movement
                const aiY = parseFloat(aiPaddle.style.top);
                if (ballY < aiY + 30) aiPaddle.style.top = Math.max(0, aiY - 3) + 'px';
                if (ballY > aiY + 30) aiPaddle.style.top = Math.min(240, aiY + 3) + 'px';
                
                // Paddle collision
                const playerY = parseFloat(playerPaddle.style.top);
                const newAiY = parseFloat(aiPaddle.style.top);
                
                if (ballX <= 30 && ballY >= playerY && ballY <= playerY + 60) {
                    ballVX = Math.abs(ballVX) * 1.05;
                    ballVY += (Math.random() - 0.5) * 2;
                }
                
                if (ballX >= 355 && ballY >= newAiY && ballY <= newAiY + 60) {
                    ballVX = -Math.abs(ballVX) * 1.05;
                    ballVY += (Math.random() - 0.5) * 2;
                }
                
                // Scoring
                if (ballX < 0) {
                    aiScore++;
                    resetBall();
                }
                if (ballX > 400) {
                    playerScore++;
                    resetBall();
                }
                
                ball.style.left = ballX + 'px';
                ball.style.top = ballY + 'px';
                
                document.getElementById('pongScore').textContent = `You: ${playerScore} | AI: ${aiScore}`;
                
                if (playerScore >= 5 || aiScore >= 5) {
                    endGame();
                    return;
                }
                
                animFrame = requestAnimationFrame(update);
            }
            
            function resetBall() {
                ballX = 192;
                ballY = 142;
                ballVX = (Math.random() > 0.5 ? 3 : -3);
                ballVY = (Math.random() - 0.5) * 4;
            }
            
            function endGame() {
                gameRunning = false;
                const reward = playerScore * 30;
                gameState.ore += reward;
                gameState.totalMined += reward;
                updateDisplays();
                saveGame();
                document.getElementById('pongScore').textContent = `${playerScore >= 5 ? 'You Win!' : 'AI Wins!'} +${reward} ore!`;
            }
            
            update();
            
            currentGameCleanup = () => {
                gameRunning = false;
                cancelAnimationFrame(animFrame);
                game.removeEventListener('mousemove', handleMove);
            };
        }

        // Breakout Game
        function breakoutGame(title, area) {
            title.textContent = 'üß± Ore Breaker';
            area.innerHTML = `
                <p>Move mouse to control paddle!</p>
                <div class="breakout-game" id="breakoutGame">
                    <div class="breakout-paddle" id="breakoutPaddle" style="left:160px;"></div>
                    <div class="breakout-ball" id="breakoutBall" style="left:194px;top:350px;"></div>
                </div>
                <p class="game-score" id="breakoutScore">Bricks: 0</p>
            `;
            
            const game = document.getElementById('breakoutGame');
            const paddle = document.getElementById('breakoutPaddle');
            const ball = document.getElementById('breakoutBall');
            
            let ballX = 194, ballY = 350;
            let ballVX = 3, ballVY = -3;
            let bricksDestroyed = 0;
            let gameRunning = true;
            let bricks = [];
            let animFrame;
            
            // Create bricks
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7'];
            for (let row = 0; row < 5; row++) {
                for (let col = 0; col < 8; col++) {
                    const brick = document.createElement('div');
                    brick.className = 'breakout-brick';
                    brick.style.cssText = `left:${col * 50 + 2}px;top:${row * 25 + 10}px;background:${colors[row]};`;
                    game.appendChild(brick);
                    bricks.push(brick);
                }
            }
            
            function handleMove(e) {
                const rect = game.getBoundingClientRect();
                const x = Math.max(0, Math.min(320, e.clientX - rect.left - 40));
                paddle.style.left = x + 'px';
            }
            
            game.addEventListener('mousemove', handleMove);
            
            function update() {
                if (!gameRunning) return;
                
                ballX += ballVX;
                ballY += ballVY;
                
                // Wall bounce
                if (ballX <= 0 || ballX >= 388) ballVX = -ballVX;
                if (ballY <= 0) ballVY = -ballVY;
                
                // Paddle bounce
                const paddleX = parseFloat(paddle.style.left);
                if (ballY >= 365 && ballX >= paddleX && ballX <= paddleX + 80) {
                    ballVY = -Math.abs(ballVY);
                    ballVX += (ballX - paddleX - 40) / 20;
                }
                
                // Ball lost
                if (ballY > 400) {
                    endGame();
                    return;
                }
                
                // Brick collision
                bricks.forEach((brick, i) => {
                    if (!brick.parentElement) return;
                    
                    const brickX = parseFloat(brick.style.left);
                    const brickY = parseFloat(brick.style.top);
                    
                    if (ballX >= brickX && ballX <= brickX + 45 &&
                        ballY >= brickY && ballY <= brickY + 20) {
                        brick.remove();
                        bricksDestroyed++;
                        ballVY = -ballVY;
                        document.getElementById('breakoutScore').textContent = `Bricks: ${bricksDestroyed}`;
                    }
                });
                
                ball.style.left = ballX + 'px';
                ball.style.top = ballY + 'px';
                
                if (bricksDestroyed >= 40) {
                    endGame();
                    return;
                }
                
                animFrame = requestAnimationFrame(update);
            }
            
            function endGame() {
                gameRunning = false;
                const reward = bricksDestroyed * 5;
                gameState.ore += reward;
                gameState.totalMined += reward;
                updateDisplays();
                saveGame();
                document.getElementById('breakoutScore').textContent = `${bricksDestroyed >= 40 ? 'You Win!' : 'Game Over!'} +${reward} ore!`;
            }
            
            update();
            
            currentGameCleanup = () => {
                gameRunning = false;
                cancelAnimationFrame(animFrame);
                game.removeEventListener('mousemove', handleMove);
            };
        }

        // Typing Game
        function typingGame(title, area) {
            title.textContent = '‚å®Ô∏è Type Rush';
            area.innerHTML = `
                <p>Type the word as fast as you can!</p>
                <div class="typing-word" id="typingWord"></div>
                <input type="text" class="typing-input" id="typingInput" autofocus>
                <p class="game-score" id="typingScore">Words: 0</p>
                <p class="game-timer" id="typingTimer">30.0s</p>
            `;
            
            const words = ['ore', 'mine', 'diamond', 'click', 'air', 'rock', 'gem', 'gold', 'silver', 'crystal', 'pickaxe', 'tunnel', 'cave', 'deep', 'shine'];
            const wordEl = document.getElementById('typingWord');
            const input = document.getElementById('typingInput');
            let wordsTyped = 0;
            let timeLeft = 30;
            let gameRunning = true;
            
            function newWord() {
                wordEl.textContent = words[Math.floor(Math.random() * words.length)];
                input.value = '';
            }
            
            function handleInput() {
                if (!gameRunning) return;
                if (input.value.toLowerCase() === wordEl.textContent.toLowerCase()) {
                    wordsTyped++;
                    document.getElementById('typingScore').textContent = `Words: ${wordsTyped}`;
                    newWord();
                }
            }
            
            input.addEventListener('input', handleInput);
            
            const timer = setInterval(() => {
                timeLeft -= 0.1;
                document.getElementById('typingTimer').textContent = timeLeft.toFixed(1) + 's';
                
                if (timeLeft <= 0) {
                    clearInterval(timer);
                    gameRunning = false;
                    const reward = wordsTyped * 50;
                    gameState.ore += reward;
                    gameState.totalMined += reward;
                    updateDisplays();
                    saveGame();
                    document.getElementById('typingTimer').textContent = `Done! +${reward} ore!`;
                    input.disabled = true;
                }
            }, 100);
            
            newWord();
            
            currentGameCleanup = () => {
                gameRunning = false;
                clearInterval(timer);
                input.removeEventListener('input', handleInput);
            };
        }

        // Color Match Game
        function colorMatchGame(title, area) {
            title.textContent = 'üé® Color Chaos';
            area.innerHTML = `
                <p>Click the button that matches the TEXT COLOR!</p>
                <div class="color-display" id="colorDisplay">RED</div>
                <div class="color-buttons" id="colorButtons"></div>
                <p class="game-score" id="colorScore">Correct: 0</p>
                <p class="game-timer" id="colorTimer">20.0s</p>
            `;
            
            const colors = [
                { name: 'RED', hex: '#ff4444' },
                { name: 'BLUE', hex: '#4444ff' },
                { name: 'GREEN', hex: '#44ff44' },
                { name: 'YELLOW', hex: '#ffff00' },
                { name: 'PINK', hex: '#ff44ff' }
            ];
            
            const display = document.getElementById('colorDisplay');
            const buttons = document.getElementById('colorButtons');
            let correct = 0;
            let timeLeft = 20;
            let gameRunning = true;
            let currentTextColor;
            
            // Create buttons
            colors.forEach(color => {
                const btn = document.createElement('button');
                btn.className = 'color-btn';
                btn.textContent = color.name;
                btn.style.background = color.hex;
                btn.style.color = color.hex === '#ffff00' ? 'black' : 'white';
                btn.addEventListener('click', () => checkAnswer(color.name));
                buttons.appendChild(btn);
            });
            
            function newRound() {
                const textColor = colors[Math.floor(Math.random() * colors.length)];
                const displayWord = colors[Math.floor(Math.random() * colors.length)];
                
                currentTextColor = textColor.name;
                display.textContent = displayWord.name;
                display.style.color = textColor.hex;
                display.style.background = 'var(--bg-tertiary)';
            }
            
            function checkAnswer(answer) {
                if (!gameRunning) return;
                if (answer === currentTextColor) {
                    correct++;
                    document.getElementById('colorScore').textContent = `Correct: ${correct}`;
                }
                newRound();
            }
            
            const timer = setInterval(() => {
                timeLeft -= 0.1;
                document.getElementById('colorTimer').textContent = timeLeft.toFixed(1) + 's';
                
                if (timeLeft <= 0) {
                    clearInterval(timer);
                    gameRunning = false;
                    const reward = correct * 40;
                    gameState.ore += reward;
                    gameState.totalMined += reward;
                    updateDisplays();
                    saveGame();
                    document.getElementById('colorTimer').textContent = `Done! +${reward} ore!`;
                }
            }, 100);
            
            newRound();
            
            currentGameCleanup = () => {
                gameRunning = false;
                clearInterval(timer);
            };
        }

        // Aim Trainer
        function aimGame(title, area) {
            title.textContent = 'üéØ Aim Trainer';
            area.innerHTML = `
                <p>Click the targets as fast as you can!</p>
                <div class="aim-game" id="aimGame"></div>
                <p class="game-score" id="aimScore">Hits: 0</p>
                <p class="game-timer" id="aimTimer">20.0s</p>
            `;
            
            const game = document.getElementById('aimGame');
            let hits = 0;
            let timeLeft = 20;
            let gameRunning = true;
            
            function spawnTarget() {
                if (!gameRunning) return;
                
                const target = document.createElement('div');
                target.className = 'aim-target';
                target.style.left = Math.random() * 350 + 'px';
                target.style.top = Math.random() * 350 + 'px';
                
                target.addEventListener('click', () => {
                    if (!gameRunning) return;
                    hits++;
                    document.getElementById('aimScore').textContent = `Hits: ${hits}`;
                    target.remove();
                    spawnTarget();
                });
                
                game.appendChild(target);
            }
            
            const timer = setInterval(() => {
                timeLeft -= 0.1;
                document.getElementById('aimTimer').textContent = timeLeft.toFixed(1) + 's';
                
                if (timeLeft <= 0) {
                    clearInterval(timer);
                    gameRunning = false;
                    const reward = hits * 15;
                    gameState.ore += reward;
                    gameState.totalMined += reward;
                    updateDisplays();
                    saveGame();
                    document.getElementById('aimTimer').textContent = `Done! +${reward} ore!`;
                }
            }, 100);
            
            spawnTarget();
            
            currentGameCleanup = () => {
                gameRunning = false;
                clearInterval(timer);
            };
        }

        // 2048 Game
        function game2048(title, area) {
            title.textContent = 'üî¢ 2048 Ore';
            area.innerHTML = `
                <p>Use arrow keys to combine tiles!</p>
                <div class="game-2048" id="game2048"></div>
                <p class="game-score" id="2048Score">Score: 0</p>
            `;
            
            const game = document.getElementById('game2048');
            let grid = Array(16).fill(0);
            let score = 0;
            let gameRunning = true;
            
            const tileColors = {
                0: '#1a1a25',
                2: '#eee4da',
                4: '#ede0c8',
                8: '#f2b179',
                16: '#f59563',
                32: '#f67c5f',
                64: '#f65e3b',
                128: '#edcf72',
                256: '#edcc61',
                512: '#edc850',
                1024: '#edc53f',
                2048: '#edc22e'
            };
            
            function addTile() {
                const empty = grid.map((v, i) => v === 0 ? i : -1).filter(i => i !== -1);
                if (empty.length === 0) return;
                const idx = empty[Math.floor(Math.random() * empty.length)];
                grid[idx] = Math.random() < 0.9 ? 2 : 4;
            }
            
            function draw() {
                game.innerHTML = '';
                grid.forEach((val, i) => {
                    const tile = document.createElement('div');
                    tile.className = 'tile-2048';
                    tile.textContent = val || '';
                    tile.style.background = tileColors[val] || '#3c3a32';
                    tile.style.color = val > 4 ? 'white' : '#776e65';
                    game.appendChild(tile);
                });
            }
            
            function slide(row) {
                let arr = row.filter(v => v);
                for (let i = 0; i < arr.length - 1; i++) {
                    if (arr[i] === arr[i + 1]) {
                        arr[i] *= 2;
                        score += arr[i];
                        arr.splice(i + 1, 1);
                    }
                }
                while (arr.length < 4) arr.push(0);
                return arr;
            }
            
            function move(direction) {
                let moved = false;
                let newGrid = [...grid];
                
                if (direction === 'left' || direction === 'right') {
                    for (let r = 0; r < 4; r++) {
                        let row = grid.slice(r * 4, r * 4 + 4);
                        if (direction === 'right') row.reverse();
                        row = slide(row);
                        if (direction === 'right') row.reverse();
                        for (let c = 0; c < 4; c++) {
                            if (newGrid[r * 4 + c] !== row[c]) moved = true;
                            newGrid[r * 4 + c] = row[c];
                        }
                    }
                } else {
                    for (let c = 0; c < 4; c++) {
                        let col = [grid[c], grid[c + 4], grid[c + 8], grid[c + 12]];
                        if (direction === 'down') col.reverse();
                        col = slide(col);
                        if (direction === 'down') col.reverse();
                        if (newGrid[c] !== col[0] || newGrid[c + 4] !== col[1] ||
                            newGrid[c + 8] !== col[2] || newGrid[c + 12] !== col[3]) moved = true;
                        newGrid[c] = col[0];
                        newGrid[c + 4] = col[1];
                        newGrid[c + 8] = col[2];
                        newGrid[c + 12] = col[3];
                    }
                }
                
                grid = newGrid;
                if (moved) {
                    addTile();
                    draw();
                    document.getElementById('2048Score').textContent = `Score: ${score}`;
                    
                    // Check for 2048
                    if (grid.includes(2048)) {
                        gameRunning = false;
                        gameState.diamondOre += 3;
                        gameState.ore += score;
                        gameState.totalMined += score;
                        updateDisplays();
                        saveGame();
                        showToast('üéâ You reached 2048! +3 Diamonds!');
                        document.getElementById('2048Score').textContent = `You Win! +${score} ore +3 üí†!`;
                    }
                }
            }
            
            function handleKeydown(e) {
                if (!gameRunning) return;
                
                const keyMap = {
                    'ArrowLeft': 'left',
                    'ArrowRight': 'right',
                    'ArrowUp': 'up',
                    'ArrowDown': 'down'
                };
                
                if (keyMap[e.key]) {
                    e.preventDefault();
                    move(keyMap[e.key]);
                }
            }
            
            document.addEventListener('keydown', handleKeydown);
            
            addTile();
            addTile();
            draw();
            
            currentGameCleanup = () => {
                gameRunning = false;
                document.removeEventListener('keydown', handleKeydown);
            };
        }

        // Endgame
        function showEndgame() {
            document.getElementById('endgameModal').classList.add('active');
        }

        document.querySelectorAll('.endgame-choice').forEach(choice => {
            choice.addEventListener('click', function() {
                const choiceType = this.dataset.choice;
                gameState.endgameChoice = choiceType;
                
                if (choiceType === 'ai') {
                    gameState.unlimitedAI = true;
                    document.getElementById('unlimitedBadge').style.display = 'inline-block';
                    document.getElementById('chatCost').textContent = '‚ú® UNLIMITED - Chat for free forever! ‚ú®';
                    document.getElementById('chatSend').textContent = 'Send (FREE!)';
                    showToast('ü§ñ Unlimited AI Unlocked!');
                } else {
                    gameState.infinityMine = true;
                    document.getElementById('infinityIndicator').style.display = 'block';
                    showToast('‚ôæÔ∏è Infinity Mine Active! +100/sec forever!');
                }
                
                saveGame();
                document.getElementById('endgameModal').classList.remove('active');
            });
        });

        // Auto mining
        setInterval(() => {
            if (gameState.autoMine > 0) {
                gameState.ore += gameState.autoMine;
                gameState.totalMined += gameState.autoMine;
                updateDisplays();
                saveGame();
            }
            
            if (gameState.infinityMine) {
                gameState.ore += 100;
                gameState.totalMined += 100;
                updateDisplays();
                saveGame();
            }
        }, 1000);

        // Floating jokes
        const jokes = [
            "The ore whispers: 'click me'",
            "Your GPU is mining... vibes",
            "Achievement: Breathing Air",
            "Error 404: Weight not found",
            "Mining difficulty: Yes",
            "Blockchain? More like airchain",
            "This game runs on hopes and dreams",
            "Try typing the cheat code üëÄ",
        ];

        function showJoke() {
            const joke = document.getElementById('floatingJoke');
            joke.textContent = jokes[Math.floor(Math.random() * jokes.length)];
            joke.style.left = Math.random() * (window.innerWidth - 200) + 'px';
            joke.style.top = Math.random() * (window.innerHeight - 100) + 'px';
            joke.classList.add('visible');
            setTimeout(() => joke.classList.remove('visible'), 3000);
        }

        // Initialize
        loadGame();
        
        if (gameState.hasCompletedIntro) {
            document.getElementById('initial-mining').classList.add('hidden');
            showMainApp();
        }

        // Auto-save every 10 seconds
        setInterval(saveGame, 10000);

        console.log('%cüí® AIR ORE üí®', 'font-size: 30px; color: #00f5ff; text-shadow: 0 0 10px #00f5ff;');
        console.log('%cMining air since 2026‚Ñ¢', 'font-size: 14px; color: #888;');
        console.log('%cPsst... try typing "iamadirtycheater" ü§´', 'font-size: 12px; color: #ff00ff;');
    </script>
</body>
</html>
